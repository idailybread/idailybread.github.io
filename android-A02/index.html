<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="http://www.gov.cn/" title="乐信圣文" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Activity是提供给用户的用于与程序进行交互的界面组件，如打电话、拍照片、发邮件、看地图等。它通过一个窗口来描画它的用户界面，通常这个窗口是全屏的，但是也可以比屏幕小，并且可以浮动在其他窗口的上面。 　　本章会略过Activity的基础知识（创建、配置、传参等），请您自行搜索学习。 第一节 生命周期　　Activity从创建到销毁会经历多个阶段，每个阶段都会回调不同的生命周期方法，本节将分">
<meta property="og:type" content="article">
<meta property="og:title" content="入门篇　第一章 Activity">
<meta property="og:url" content="http://yoursite.com/android-A02/index.html">
<meta property="og:site_name" content="乐信圣文">
<meta property="og:description" content="Activity是提供给用户的用于与程序进行交互的界面组件，如打电话、拍照片、发邮件、看地图等。它通过一个窗口来描画它的用户界面，通常这个窗口是全屏的，但是也可以比屏幕小，并且可以浮动在其他窗口的上面。 　　本章会略过Activity的基础知识（创建、配置、传参等），请您自行搜索学习。 第一节 生命周期　　Activity从创建到销毁会经历多个阶段，每个阶段都会回调不同的生命周期方法，本节将分">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/android/android_2_1.png">
<meta property="og:image" content="http://yoursite.com/img/android/android_2_7.png">
<meta property="og:image" content="http://yoursite.com/img/android/android_2_8.png">
<meta property="og:image" content="http://yoursite.com/img/android/android_2_13.png">
<meta property="og:image" content="http://yoursite.com/img/android/android_2_3.png">
<meta property="og:image" content="http://yoursite.com/img/android/android_2_4.png">
<meta property="og:image" content="http://yoursite.com/img/android/android_2_5.png">
<meta property="og:image" content="http://yoursite.com/img/android/android_2_6.png">
<meta property="og:updated_time" content="2018-09-09T10:47:48.457Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="入门篇　第一章 Activity">
<meta name="twitter:description" content="Activity是提供给用户的用于与程序进行交互的界面组件，如打电话、拍照片、发邮件、看地图等。它通过一个窗口来描画它的用户界面，通常这个窗口是全屏的，但是也可以比屏幕小，并且可以浮动在其他窗口的上面。 　　本章会略过Activity的基础知识（创建、配置、传参等），请您自行搜索学习。 第一节 生命周期　　Activity从创建到销毁会经历多个阶段，每个阶段都会回调不同的生命周期方法，本节将分">
<meta name="twitter:image" content="http://yoursite.com/img/android/android_2_1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/android-A02/"/>

  <title> 入门篇　第一章 Activity | 乐信圣文 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?53b4b0b5aeb5df5e4fb6263a58d8e1a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">乐信圣文</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feedback">
          <a href="/feedback" rel="section">
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                入门篇　第一章 Activity
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-30T23:28:28+08:00" content="2014-10-30">
              2014-10-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android开发-倔强青铜/" itemprop="url" rel="index">
                    <span itemprop="name">Android开发 - 倔强青铜</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/android-A02/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="android-A02/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/android-A02/" class="leancloud_visitors" data-flag-title="入门篇　第一章 Activity">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>　　<code>Activity</code>是提供给用户的用于与程序进行交互的界面组件，如打电话、拍照片、发邮件、看地图等。它通过一个窗口来描画它的用户界面，通常这个窗口是全屏的，但是也可以比屏幕小，并且可以浮动在其他窗口的上面。</p>
<p>　　本章会略过<code>Activity</code>的基础知识（创建、配置、传参等），请您自行搜索学习。<br><br></p>
<h1 id="第一节-生命周期"><a href="#第一节-生命周期" class="headerlink" title="第一节 生命周期"></a>第一节 生命周期</h1><p>　　Activity从创建到销毁会经历多个阶段，每个阶段都会回调不同的生命周期方法，本节将分两部分来介绍它的生命周期。</p>
<h2 id="正常生命周期"><a href="#正常生命周期" class="headerlink" title="正常生命周期"></a>正常生命周期</h2><p>　　在正常情况下，Activity会执行下面<code>7</code>个生命周期方法：</p>
<pre><code>onCreate、onStar、onResume、onRestart、onPause、onStop、onDestroy
</code></pre><p><br>　　下图说明了这些生命周期方法之间转换可能的路径：</p>
<center><br><img src="/img/android/android_2_1.png" alt="Activity的生命周期方法"><br></center>

<p><br>　　下面将详细介绍这七个生命周期方法。</p>
<p><br>　　<strong>onCreate()</strong></p>
<pre><code>-  当Activity构造方法返回之后，系统会调用这个方法，创建各种全局资源，如设置界面布局等。
-  在Activity的整个生命周期中，此方法仅会调用一次。
</code></pre><p><br>　　<strong>onRestart()、onStart()、onResume()</strong></p>
<pre><code>-  onRestart：当Activity从不可见即将变为可见状态时，此方法会被调用。注意上图，一个新创建的Activity不会调用此方法。
-  onStart：  当Activity已经可见时，此方法会被调用，此时Activity还无法和用户交互。
-  onResume： 当Activity已经可见且可以和用户交互时，此方法会被调用。
</code></pre><p><br>　　<strong>onPause()</strong></p>
<pre><code>-  当Activity可见但不能和用户交互时，此方法会被调用。它强调Activity即将不可见，而onStart强调Activity即将可交互。
-  通常，此方法中会进行数据持久化，终止动画等操作。
</code></pre><p>　　当在同一个进程中的两<code>Activity</code>之间切换时，它们两个的生命周期都会发生变化，以下是<code>ActivityA</code>启动<code>ActivityB</code>时发生的操作：</p>
<pre><code>-  ActivityA的onPause方法被执行。
-  ActivityB的onCreate、onStart、和onResume被顺序执行（现在ActivityB有用户焦点）。
-  如果ActivityA不再屏幕上显示，它的onStop方法就会被执行。
</code></pre><p>　　这意味着，在<code>ActivityA</code>的<code>onPause</code>方法返回之前，<code>ActivityB</code>的<code>onCreate</code>方法不会被调用，因此请不要在<code>onPause</code>方法中执行耗时操作。<br>　　另外，当操作系统内存不足且需要为高优先级的应用程序分配内存资源时，系统可能销毁处于pause状态的Activity，因此<code>onPause()</code>方法是Activity可以保证一定会执行的最后的一个生命周期方法。</p>
<p><br>　　<strong>onStop()</strong></p>
<pre><code>-  当Activity即将不再对用户可见时调用这个方法。有两种情况：
   -  第一，当前Activity被销毁。
   -  第二，另一个Activity被显示出来且完全挡住了当前Activity。
-  注意：当系统内存不足时系统会将已经调用过onPause()方法Activity给回收掉，也就是说此方法不一定会被调用。
</code></pre><p><br>　　<strong>onDestroy()</strong></p>
<pre><code>-  在Activity被销毁之前调用这个方法，这是Activity收到的最后的调用。
-  注意：当系统内存不足时系统会将已经调用过onPause()方法Activity给回收掉，也就是说此方法不一定会被调用。
</code></pre><h2 id="异常生命周期"><a href="#异常生命周期" class="headerlink" title="异常生命周期"></a>异常生命周期</h2><p>　　上一节我们介绍了<code>Activity</code>常见的<code>7</code>个生命周期方法，这些方法主要是依靠用户的操作来触发的，比如用户打开一个新的<code>Activity</code>，会导致当前界面的<code>onPause</code>等方法调用。<br>　　但是实际开发时，情况会稍微复杂一些，我们还会涉及到其它几个生命周期方法，本节就来介绍一下它们。<br><br></p>
<h3 id="设备配置改变"><a href="#设备配置改变" class="headerlink" title="设备配置改变"></a>设备配置改变</h3><p>　　当设备配置在运行期间改变（如屏幕方向、语言等）时，系统会重启正在运行的Activity（系统调用onDestroy()方法后，立即调用onCreate()方法）。<br>　　但是你也可以修改这个默认的行为，从而阻止系统重启你的Activity，即告诉系统由Activity自己来处理配置变化。</p>
<p><br>　　我们只需要设置清单文件的<code>&lt;activity&gt;</code>元素的<code>android:configChanges</code>属性即可，该属性最常用的值是<code>orientation</code>(处理当屏幕的方向变化)，多个配置的值之间通过<code>“|”</code>符号将它们分隔开。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MyActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">"orientation|screenSize"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　这样一来当屏幕方向发生变化时，<code>MyActivity</code>不会重新启动，相反，它的<code>onConfigurationChanged()</code>方法会被系统的调用，如果您没这么配置则不会被调用。</p>
<p>　　注意：</p>
<pre><code>-  从Android3.2(API level 13)开始，当屏幕在横竖屏间切换时也会导致“screenSize”改变。
-  因此若想在APILevel 13或更高的版本中防止屏幕方向变化时重启Activity，你必须同时包含“screenSize”和“orientation”两个值。
</code></pre><p><br>　　例如，接下来的<code>onConfigurationChanged()</code>方法中实现了检查当前设备的方向：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当这个方法被调用时，你的Activity的Resources对象会被更新并返回一个基于新配置的Resources对象。</span></span><br><span class="line"><span class="comment">// 因此你可以在不用系统重启你的Activity的情况下很容易地重置你的UI元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"landscape"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"portrait"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　另外，不论你是同时设置<code>“screen size”</code>和<code>“orientation”</code>还是将<code>targetSdkVersion</code>设置为<code>&lt;=13</code>，它们都只是会阻止<code>Activity</code>的重建，但并不会阻止屏幕的横竖屏切换。<br>　　如果你想让<code>Activity</code>支持横屏或竖屏二者之一，那么应该使用<code>android:screenOrientation</code>属性。<br><br></p>
<h3 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h3><p>　　程序在运行时会遇到各种各样的突发事件，当这些事件发生时就会导致Activity被重建，除了上面说的屏幕方向改变外，系统内存不足也是一个常见的、导致后台进程中的Activity被杀掉的原因。<br>　　也就是说，即便我们避免了屏幕方向改变导致的Activity被重建的情况，但是Activity还会因为其他原因而重建。</p>
<p><br>　　为了应对这些突发事件，系统在Activity类中为我们提供了如下两个回调方法：</p>
<pre><code>-  onSaveInstanceState：
   -  在Activity有可能被销毁之前，系统会回调此方法。
   -  我们重写此方法时，将自己需要保存的数据，存在该方法的参数（一个Bundle对象）中即可。
-  onRestoreInstanceState：
   -  如果Activity之前存储了数据，则当该Activity再次被显示时，系统会回调此方法。
   -  我们重写此方法时，从该方法的参数（一个Bundle对象）中还原我们的数据即可。
</code></pre><p><br>　　范例1：保存数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        <span class="comment">// 保存一个int变量到Bundle对象中。</span></span><br><span class="line">        outState.putInt(<span class="string">"key"</span>, <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">        <span class="comment">// 从Bundle中读取数据。</span></span><br><span class="line">        System.out.println(<span class="string">"onRestoreInstanceState "</span> + savedInstanceState.get(<span class="string">"key"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  Activity的onCreate方法的Bundle对象与onRestoreInstanceState是同一个。
-  如果没有需要恢复的状态信息，那么会传递给onCreate方法一个null的Bundle的对象（Activity首次被创建时）。
-  一般情况下，我们推荐在onRestoreInstanceState中执行还原操作。
</code></pre><p><br>　　注意：</p>
<pre><code>-  在Activity被销毁之前不能保证onSaveInstanceState()方法被调用。
-  因为有些场景中不需要保存状态，如用户使用“BACK”键退出时，因为用户明确的要关闭Activity就不需要保存状态了。
-  如果系统需要，则：
   -  会在onPause()方法之前调用onSaveInstanceState()方法。
   -  会在onResume()之前调用onRestoreInstanceState()方法。
</code></pre><p><br>　　但是，如果你没有重写<code>onSaveInstanceState()</code>方法，那么Activity类默认的<code>onSaveInstanceState()</code>方法也能恢复某些状态：</p>
<pre><code>-  在Android框架中几乎每个Widget都对onSaveInstanceState()方法做了适当的实现。
-  Activity的onSaveInstanceState()方法，会依次调用它自己的布局中的View的onSaveInstanceState()方法，来保存数据。
   -  比如当Activity被重建时，EditText控件保存用户输入的文本、CheckBox控件保存是否被选中。
-  需要你做的工作只是给每个要保存状态的View提供一个唯一的ID（使用android:id属性）即可，系统不会保存未提供Id的View的状态。
</code></pre><h1 id="第二节-Task"><a href="#第二节-Task" class="headerlink" title="第二节 Task"></a>第二节 Task</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>　　<code>Android</code>使用<code>Task</code>来组织应用程序的所有<code>Activity</code>，<code>Task</code>是一个栈(<code>Stack</code>)结构，各个<code>Activity</code>按照栈的特点<code>“后来居上、后进先出”</code>依次被安排在栈中。<br>　　默认情况下，一个应用程序中的所有<code>Activity</code>处于同一个<code>Task</code>中，在操作系统中同一时间上会存在多个<code>Task</code>。<br>　　默认情况下，当一个<code>Activity</code>被创建时，就会被压入到<code>Task</code>的栈顶，当其销毁时（用户点击<code>“Back”</code>键或调用<code>finish()</code>方法等），就会从栈顶移除。</p>
<p><br>　　范例1：图示。<br>　　　　　　　　<img src="/img/android/android_2_7.png" alt="Task"><br>　　第四个图形描述的是<code>Activity3</code>从<code>Task</code>中被弹出。<br>　　如果用户继续按<code>“Back”</code>按钮，那么堆栈中的每个<code>Activity</code>会被依次弹出，当所有的<code>Activity</code>从堆栈中被删除时，这个<code>Task</code>就不再存在了。</p>
<p><br>　　范例2：前台与后台。<br>　　<code>Task</code>有前台和后台之分，当某个应用程序被用户切换到前台时，该应用程序所对应的<code>Task</code>也将会被移动到前台。<br>　　　　　　　　　　　　　　　　　　<img src="/img/android/android_2_8.png" alt="TaskB处于前台、TaskA处于后台"></p>
<p>　　很显然，系统在同一时间可能存在多个后台<code>Task</code> ，但只能有一个前台<code>Task</code>。<br>　　提示：虽然后台可以存在多个<code>Task</code>，但是当系统内存不足时，后台<code>Task</code>中的<code>Activity</code>所占据的内存可能被回收。</p>
<p><br>　　<code>Task</code>的默认行为：</p>
<pre><code>-  当用户通过按主页（Home）按钮离开一个Task（任务）时，当前Task的栈顶Activity会被stop，并且Task会被放入后台，但系统会保留Task中每个Activity的状态。
   -  如果用户随后通过选择启动图标来恢复这个任务，那么任务会来到前台，并且恢复了堆栈顶部的Activity。
-  如果用户按下回退按钮，当前的Activity会从堆栈中被弹出并且被销毁，堆栈中的前一个Activity会被恢复。
</code></pre><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p>　　默认情况下，<code>Android</code>会把同一个应用程序的所有<code>Activity</code>放到同一个栈里来进行管理，对于大多数应用程序来说这种方法能够很好的工作。<br>　　但是实际应用时情况复杂多变，这种默认的行为难以满足一些特殊的需求，不过你可以修改它，即<code>修改启动模式</code>。</p>
<p><br><strong>修改启动模式：</strong><br>　　启动模式用来告诉系统，当用户请求启动一个<code>Activity</code>时，系统应该怎么做。使用以下两种方法可以定义启动模式：</p>
<pre><code>1、 使用清单文件：即在配置Activity的同时，指定该Activity的启动模式。
2、 使用Intent对象：在调用startActivity方法时，通过Intent对象来设置待启动的Activity的启动模式。
</code></pre><p><br>　　假设<code>ActivityA</code>启动<code>ActivityB</code>，并且：</p>
<pre><code>-  B在清单文件中定义了自己的启动模式。
-  同时A又通过在Intent中设置了flag的方式，来为B指定启动模式。
</code></pre><p>　　那么此时<code>A</code>的请求（在<code>Intent</code>中定义的）的优先级要高于<code>B</code>的请求（在清单文件中定义的）。<br><br>　　注意：某些在清单文件中有的启动模式在<code>Intent</code>类中却没有，同样某些<code>Intent</code>类有的启动模式也不能在清单文件中使用。<br><br></p>
<h3 id="使用清单文件"><a href="#使用清单文件" class="headerlink" title="使用清单文件"></a>使用清单文件</h3><p>　　在清单文件中声明一个<code>Activity</code>时，你能够使用<code>&lt;activity&gt;</code>元素的<code>launchMode</code>属性来指定这个<code>Activity</code>的启动模式，该属性有有四种取值：</p>
<p><br>　　<strong>standard模式</strong></p>
<pre><code>-  标准模式，如果你在清单文件中配置Activity时，不为它的launchMode属性赋值，那么该Activity就默认是此种启动模式。
-  当启动一个standard模式的Activity时，系统会直接创建一个该Activity的实例，并将该实例放到启动者所在的Task的栈顶。
   -  比如ActivityA启动了ActivityB（B是标准模式），那么B就会运行在A所在的栈中，即使A与B不是一个应用程序也不例外。
-  如果A启动了5次B，那么A的Task中就有5个B的实例。
</code></pre><p>　　当我们用<code>Application</code>或<code>Service</code>对象来启动一个<code>standard</code>模式的Activity时，会报如下错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: android.util.AndroidRuntimeException: <span class="function">Calling <span class="title">startActivity</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">            from outside of an Activity  context <span class="keyword">requires</span> the FLAG_ACTIVITY_NEW_TASK flag. </span></span><br><span class="line"><span class="function">            Is <span class="keyword">this</span> really what you want?</span></span><br></pre></td></tr></table></figure></p>
<p>　　这是因为<code>standard</code>模式的Activity默认会进入它的启动者的Task中，但是由于Application并没有所谓的Task的概念，所以就出问题了。</p>
<p><br>　　<strong>singTop模式</strong></p>
<pre><code>-  栈顶复用模式。如果打算启动的Activity的实例，已经存在于启动者所在的Task的顶部，那么系统就会通过调用onNewIntent方法把这个Intent传递给这个实例，而不是创建一个新的实例。
-  只有启动者所在的栈的顶部的Activity不是该Activity的实例时才会有多个实例存在。
</code></pre><p><br>　　假设现在有一个<code>Task</code>，它的栈由<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>四个<code>Activity</code>组成，其中<code>D</code>在栈顶。</p>
<pre><code>-  若此时又试图启动一个D类型Activity，那么：
   -  若D的启动模式是standard，那么D就会被直接启动，并且此时堆栈变成A-B-C-D-D的组合。
   -  若D的启动模式是singleTop，那么既存的D的实例因为它在堆栈的顶部，所以它会接收通过onNewIntent()方法传递的Intent，堆栈仍然保持着A-B-C-D的组合。
-  但是，如果是启动一个B类型Activity，那么即使B类型Activity的启动模式是“singleTop”，也会有一个新的B的实例被添加到堆栈中，因为栈顶是D。
</code></pre><p><br>　　在讲解<code>singleTask</code>启动模式之前，先说明一下什么是<code>affinity</code>。<br><br>　　<strong>affinity：</strong><br>　　每个<code>Task</code>都有一个<code>affinity</code>属性，它相当于<code>Task</code>的名字。<br>　　每个<code>&lt;activity&gt;</code>标签也有一个<code>taskAffinity</code>的属性，用来指出当前<code>Activity</code>想从属的Task。</p>
<pre><code>-  若Activity为它的taskAffinity属性设置了值，即告诉系统该Activity希望被放到affinity属性的值与其taskAffinity属性相同的Task中。
-  若没有为此属性赋值，则当前Activity的affinity就是&lt;application&gt;标签的taskAffinity属性的值。
-  若&lt;application&gt;标签也没有指定taskAffinity属性的值，则就使用包名来作为整个程序所有Activity的taskAffinity。
   -  也就是说，默认情况下同一个应用程序中的所有Activity，会运行在同一个Task中。
</code></pre><p>　　<br>　　问：那么<code>affinity</code>在什么情况下会被用到呢?<br>　　答：<code>taskAffinity</code>属性主要和<code>singleTask</code>等启动模式或者<code>allowTaskReparenting</code>属性配对使用。</p>
<p><br>　　<strong>singleTask模式</strong><br>　　当启动了一个启动模式为<code>singleTask</code>的<code>Activity</code>时，系统会执行如下操作：</p>
<pre><code>-  在整个操作系统中当前正在运行的所有Task中进行查找，查找affinity属性值等于启动模式为singleTask的Activity的taskAffinity属性值的任务是否存在。
-  若不存在，则系统会开启一个新的Task，并将该Activity作为根元素。
-  若存在，则系统会查看该Task中是否已经存在了该Activity。
   -  若存在，则将该Activity上的所有Activity都给finish掉，并调用该Activity的onNewIntent()方法，将新的Intent传递过去。
   -  若不存在，则在该Task顶部启动该Activity。
</code></pre><p>　　提示：<code>singleTask</code>默认具有<code>clearTop</code>的效果。</p>
<p><br>　　范例1：查看所有<code>Task</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity</span><br></pre></td></tr></table></figure></p>
<p>　　使用<code>adb</code>命令可以查看当前操作系统中存在的所有<code>Task</code>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">   TaskRecord&#123;44fbd658 #3 A com.example.androidtest&#125;</span><br><span class="line">     Run #1: HistoryRecord&#123;45032428 com.example.androidtest/.MainActivity&#125;</span><br><span class="line">   TaskRecord&#123;4502d408 #2 A com.android.launcher&#125;</span><br><span class="line">     Run #0: HistoryRecord&#123;4502ab48 com.android.launcher/com.android.launcher2.Launcher&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　此时系统中有两个<code>Task</code>，若在<code>MainActivity</code>中启动<code>Activity1</code>，在<code>Activity1</code>中启动<code>Activity2</code>，则<code>Task</code>中的情况如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">  TaskRecord&#123;4500ff48 #4 A com.example.androidtest&#125;</span><br><span class="line">    Run #3: HistoryRecord&#123;450ea0a8 com.example.androidtest/.Activity2&#125;</span><br><span class="line">    Run #2: HistoryRecord&#123;450268f8 com.example.androidtest/.Activity1&#125;</span><br><span class="line">    Run #1: HistoryRecord&#123;44eb1ea8 com.example.androidtest/.MainActivity&#125;</span><br><span class="line">  TaskRecord&#123;4502d408 #2 A com.android.launcher&#125;</span><br><span class="line">    Run #0: HistoryRecord&#123;4502ab48 com.android.launcher/com.android.launcher2.Launcher&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　若修改<code>Activity1</code>的启动模式为<code>singleTask</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".Activity1"</span> <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span> &gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　则在<code>MainAcitivity</code>中启动它后，栈中的情况如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Running <span class="title">activities</span> <span class="params">(most recent first)</span>:</span></span><br><span class="line">   TaskRecord&#123;45008f00 #6 A com.example.androidtest&#125;</span><br><span class="line">     Run #2: HistoryRecord&#123;45040e18 com.example.androidtest/.Activity1&#125;</span><br><span class="line">     Run #1: HistoryRecord&#123;44f8eed0 com.example.androidtest/.MainActivity&#125;</span><br><span class="line">   TaskRecord&#123;4502d408 #2 A com.android.launcher&#125;</span><br><span class="line">     Run #0: HistoryRecord&#123;4502ab48 com.android.launcher/com.android.launcher2.Launcher&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　为什么没有新开启一个<code>Task</code>呢?<br>　　因为<code>Activity</code>的<code>taskAffinity</code>属性的值没有设置，因此最终系统将它默认为包名了，这和<code>MainAcitivity</code>所处的<code>Task</code>的<code>affinity</code>属性的值一致，所以没有新开<code>Task</code>。</p>
<p><br>　　范例2：开启新<code>Task</code>。<br>　　首先为<code>Activity1</code>设置<code>taskAffinity</code>属性的值。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".Activity1"</span> <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"ni.die"</span> &gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　然后在<code>MainAcitivity</code>中启动它，此时系统中的<code>Task</code>情况如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Running activities (most recent first):</span><br><span class="line">   TaskRecord&#123;44f1e948 #8 A ni.die&#125;</span><br><span class="line">     Run #2: HistoryRecord&#123;45028690 com.example.androidtest/.Activity1&#125;</span><br><span class="line">   TaskRecord&#123;4500b308 #7 A com.example.androidtest&#125;</span><br><span class="line">     Run #1: HistoryRecord&#123;44eb1ea8 com.example.androidtest/.MainActivity&#125;</span><br><span class="line">   TaskRecord&#123;4502d408 #2 A com.android.launcher&#125;</span><br><span class="line">     Run #0: HistoryRecord&#123;4502ab48 com.android.launcher/com.android.launcher2.Launcher&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　<strong>移动整个栈</strong><br>　　这里需要指出一种情况，我们假设目前有2个任务栈，前台栈中有AB，后台栈中有CD，且假设CD的启动模式均为<code>singleTask</code>。<br>　　然后处于前台栈顶的B：</p>
<pre><code>-  如果请求启动D：由于D是栈顶，那么整个后台栈都会被切换到前台，此时的序列为ABCD。
-  如果请求启动C：由于C不是栈顶，因此请求C时，D会被直接出栈，此时的序列为ABC。
</code></pre><p><br>　　<strong>singleInstance模式</strong><br>　　使用此启动模式的<code>Activity</code>总是单独占有一个<code>Task</code>，若在该<code>Activity</code>中又启动了另外一个<code>Activity</code>，则新启动的<code>Activity</code>将不会和该<code>Activity</code>处于同一个<code>Task</code>中。</p>
<p>　　需要注意的是：<code>singleInstance</code>模式也会使用<code>taskAffinity</code>属性。</p>
<pre><code>-  假设我们有A、B两个Activity，其中A是standard模式，B是singleInstance模式的，并且它俩都没有指定taskAffinity属性，同时我们的包名为com.cutler.androidtest。
-  由于B是singleInstance模式，所以它必须单独占据一个栈，那么当我们在A中启动B时会发生什么呢？ 如下图所示。
</code></pre><center><br><img src="/img/android/android_2_13.png" alt=""><br></center>

<p>　　从上面可以看出<code>BActivity</code>仍然会被放到<code>com.cutler.androidtest</code>中，但是它和<code>AActivity</code>却分别处在不同的两个栈中。</p>
<p><br></p>
<h3 id="使用Intent"><a href="#使用Intent" class="headerlink" title="使用Intent"></a>使用Intent</h3><p>　　启动<code>Activity</code>时，你能够通过在传递给<code>startActivity()</code>方法的<code>Intent</code>中包含标识来修改<code>Activity</code>的默认启动模式，常用的取值：</p>
<pre><code>-  FLAG_ACTIVITY_NEW_TASK：与launchMode属性值等于singleTask时具有同样的行为。
-  FLAG_ACTIVITY_SINGLE_TOP:与launchMode属性值等于singleTop时具有同样的行为。
</code></pre><p><br>　　范例1：设置<code>Flag</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line"><span class="keyword">this</span>.startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在非Activity中启动Activity时，必须为Intent设置FLAG_ACTIVITY_NEW_TASK，如在“服务”中。
</code></pre><p><br><strong>清除回退堆栈（笔者未测试）：</strong><br>　　如果用户长时间的离开一个任务，那么系统会清除这个任务根<code>Activity</code>以外的所有<code>Activity</code>。当用户再次返回这个任务时，只有根<code>Activity</code>被存储。这样的系统行为是因为经过长时间以后，用户在返回这个任务之前可能已经放弃它们的作业，而开始了某些新的任务。 你能够使用一些<code>Activity</code>属性来修改这种行为：</p>
<p>　　alwaysRetainTaskState</p>
<pre><code>如果这个属性在一个任务的根Activity中被设置为“true”，那么像上面描述的那样的默认行为就不会发生。即使是长时间之后，这个任务也会在它的堆栈中保留所有的Activity。
</code></pre><p>　　clearTaskOnLaunch</p>
<pre><code>如果这个属性在一个任务的根Activity中被设置为“true”，那么无论用户什么时候离开和返回这个任务，堆栈都会被清除到根Activity的位置。换句话说，它与alwaysRetainTaskState属性相反，用户总是返回到任务的初始状态，即使只离开这个任务一会儿。
</code></pre><h1 id="第三节-Intent"><a href="#第三节-Intent" class="headerlink" title="第三节 Intent"></a>第三节 Intent</h1><p>　　<code>Android</code>四大组件中有三个组件（不包括内容提供者）是通过叫做<code>Intent</code>的对象来激活的，因此接下来将介绍<code>Intent</code>对象。</p>
<p>　　Intent被译为意图，一个Intent对象就是一个信息包，我们把一些信息放到Intent中，然后把它交给操作系统，然后操作系统会依据里面的数据来做出相应的操作。</p>
<p>　　Intent中主要有<code>7</code>个重要的字段：</p>
<pre><code>mComponent、mAction、mData、mCategories、mExtras、mType、mFlags
</code></pre><p>　　但是我们在使用Intent对象的时候，不需要为这7个属性都赋值，而只需要在不同的情况下为某几个属性赋值即可，稍后会详细介绍如何使用它们。</p>
<p><br>　　在<code>Android</code>中意图分为：<code>显式意图</code>和<code>隐式意图</code>。<br><br>　　<strong>显式意图</strong><br>　　若在<code>Intent</code>对象被发送给操作系统之前，程序为它的<code>mComponent</code>属性赋值了，则此<code>Intent</code>对象被称为显式意图。显示意图明确的指定了其要启动的组件的所在包名、类名，<code>Android</code>系统接到<code>Intent</code>对象时，直接去对应的包中反射实例化并初始化目标组件。<br><br>　　<strong>隐式意图</strong><br>　　在程序中没有为<code>Intent</code>对象明确指出想要其启动的组件（即没有为<code>mComponent</code>属性赋值），而是提供一些筛选条件，操作系统会从当前已在系统中注册的所有组件中，筛选出满足要求的组件(可能是一个也可能是多个)，然后予以启动。 </p>
<h2 id="显式意图"><a href="#显式意图" class="headerlink" title="显式意图"></a>显式意图</h2><p>　　当操作系统接到<code>Intent</code>对象后，会检查<code>Intent</code>对象的<code>mComponent</code>是否有值：</p>
<pre><code>-  若有值：则直接启动mComponent所代表的组件。
-  若无值：则按照隐式意图处理。
</code></pre><p>　　<code>mComponent</code>字段是<code>ComponentName</code>类型的，用来表示<code>Intent</code>所要启动的组件的名字，它只有两个属性：<code>包名</code>、<code>组件名</code>。</p>
<pre><code>-  包名：用来指出该组件所在的应用程序。
-  组件名：找到应用程序后，再依据组件名，来在该程序中找对应的组件。
</code></pre><p><br>　　范例1：通过<code>ComponentName</code>启动新<code>Activity</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ComponentName component = <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">        <span class="comment">// 输出com.example.androidtest.SecondActivity</span></span><br><span class="line">        System.out.println(component.getClassName()); </span><br><span class="line">        <span class="comment">// 输出com.example.androidtest</span></span><br><span class="line">        System.out.println(component.getPackageName()); </span><br><span class="line">        <span class="comment">// 输出.SecondActivity</span></span><br><span class="line">        System.out.println(component.getShortClassName()); </span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        <span class="comment">// 往Intent中添加数据</span></span><br><span class="line">        intent.putExtra(<span class="string">"name"</span>, <span class="string">"tom"</span>);</span><br><span class="line">        intent.setComponent(component);</span><br><span class="line">        <span class="comment">// 启动SecondActivity</span></span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  我们可以通过Intent对象的mExtras属性，来将一些参数传递到目标组件中去。
-  也可以在创建Intent对象的同时，设置当前Intent对象从何处跳往何处：
   -  Intent intent = new Intent(MainActivity.this,MyActivity.class);
</code></pre><p><br>　　范例2：接收参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(android.os.Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main2);</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">this</span>.getIntent();</span><br><span class="line">        System.out.println(intent.getStringExtra(<span class="string">"name"</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  每个Activity都拥有一个启动自己的Intent对象，可以通过getIntent()方法获取。
</code></pre><h2 id="隐式意图"><a href="#隐式意图" class="headerlink" title="隐式意图"></a>隐式意图</h2><p>　　隐式意图：在程序中没有为<code>Intent</code>对象的<code>mComponent</code>属性明确指出想要其启动组件。<br>　　隐式意图仅仅是为<code>Intent</code>对象指出一些筛选条件，然后<code>Android</code>系统会取出<code>Intent</code>对象中的数据和所有已经注册到系统中的组件进行匹配。</p>
<pre><code>-  若匹配成功，则系统将激活该组件。
-  若有多个组件匹配成功，则系统将弹出一个对话框，要求用户选择所要激活的组件。
-  若没有任何组件匹配成功则抛异常。
</code></pre><p>　　应用程序中定义的<code>Android</code>组件都需要在<code>AndroidManifest.xml</code>文件中记录。当系统在进行意图匹配时，就会取出<code>Intent</code>对象中的筛选条件与所有已注册到系统中的各个组件的<code>&lt;intent-filter&gt;</code>标签下定义的数据进行匹配。</p>
<p>　　上面所说的“筛选条件”指的就是<code>Intent</code>对象以下三个方面：</p>
<pre><code>1、动作（mAction）
2、数据（mData和mType）
3、分类（mCategories）
</code></pre><p>　　也就是说，我们通过为Intent的上面四个属性赋值，来设置“筛选条件”，然后操作系统也会读取这四个属性，并用它们进行匹配。</p>
<p><br><strong>动作</strong><br>　　<code>mAction</code>：是<code>String</code>类型的，用来告诉系统本次请求要执行什么样的动作。如：张三看书、李四唱歌中的<code>“看”</code>、<code>“唱”</code>就是指动作。在Android中内置的动作有很多，常见的有：</p>
<pre><code>-  Intent.ACTION_VIEW ：“查看”动作。
-  Intent.ACTION_EDIT ：“编辑”动作。
-  Intent.ACTION_DELETE ：“删除”动作。
-  Intent.ACTION_CALL：“呼叫”动作，通常指打电话。
-  Intent.ACTION_MAIN ：标记当前Activity是程序的入口。
</code></pre><p><br><strong>数据</strong><br>　　数据：<code>“动作”</code>所要操作的数据，显然不同的动作要跟不同的数据规范类型配合使用，比如：</p>
<pre><code>-  如果动作是ACTION_VIEW，那么数据就应该指向一个可被查看的东西，比如网页、图片、视频等。
-  如果动作字段是ACTION_EDIT，那么它的数据应该指向它所要编辑的数据。
-  如果动作是ACTION_CALL，那么数据就应该是一个呼叫号码。
</code></pre><p>　　再具体点说，数据包括两部分：<code>mData</code>和<code>mType</code>：</p>
<pre><code>-  数据的URI(mData)：用来指出数据所在的位置。如file:///tmp/android.txt。
-  数据的类型(mType)：用来指出数据的MIME类型。如：text/html 。
</code></pre><p><br><strong>分类</strong><br>　　<code>mCategories</code>：<code>“动作”</code>的附加信息（可以有多个）。在Android中内置的类型有：</p>
<pre><code>-  Intent.CATEGORY_LAUNCHER ：目标Activity能够被列在应用程序启动器上。
-  Intent.CATEGORY_BROWSABLE ：目标Activity能够安全的调用浏览器来显示链接所指向的数据（如图片或电子邮件）。
-  Intent.CATEGORY_HOME ：目标Activity显示在主屏幕上。
</code></pre><p><br></p>
<h3 id="IntentFilter类"><a href="#IntentFilter类" class="headerlink" title="IntentFilter类"></a>IntentFilter类</h3><p>　　通过前面的介绍，我们已经知道这三点：</p>
<pre><code>-  创建完Activity等组件后，还需要在清单文件中配置它们，以便让系统知道这些组件的存在。
-  在配置它们的时候，除了ContentProvider之外的另外三个组件都可以配置一个或多个&lt;IntentFilter&gt;，它表示过滤器。
-  当我们需要启动一个组件时，整个流程是这样的：
   -  首先，我们创建一个Intent对象，然后将它传递给操作系统。
   -  然后，系统会检测Intent，若它是显式意图的直接启动目标组件，否则会依据Intent内部的信息进行匹配。
   -  接着，如果我们调用的startActivity来启动组件，那么系统会获取当前所有注册到系统中的Activity，并获取它们的&lt;IntentFilter&gt;。
   -  最后，让Intent对象和这些Activity的&lt;IntentFilter&gt;进行匹配，匹配成功就会启动该Activity，若有多个Activity都匹配成功，则系统会让用户选择启动哪一个。
   -  另外，组件可以有多个&lt;IntentFilter&gt;标签，只要该组件有一个匹配成功，则就能启动。
</code></pre><p>　　<code>IntentFilter</code>类与<code>&lt;IntentFilter&gt;</code>标签对应，它有类似于Intent对象的动作、数据、和分类字段。</p>
<p><br><strong>Action匹配</strong><br>　　在清单文件中的<code>&lt;intent-filter&gt;</code>元素内的<code>&lt;action&gt;</code>子元素对应咱们前面说的“动作”。如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.project.SHOW_CURRENT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.project.SHOW_RECENT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.project.SHOW_PENDING"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  像本例显示的这样，一个过滤器可以列出多个Action。但这个列表不能是空的，一个过滤器必须包含至少一个&lt;action&gt;元素，否则它不会匹配任何Intent对象。
-  要通过这个检测，在Intent对象中指定的Action必须跟这个过滤器的动作列表中的某个Action一致匹配。
</code></pre><p>　　<br>　　进行意图匹配时，只有在Intent的<code>mAction</code>属性与<code>&lt;intent-filter&gt;</code>下的某个<code>&lt;action&gt;</code>标签的值匹配成功后，才会去匹配<code>mCategories</code>属性。 </p>
<p><br><strong>Category检测</strong><br>　　<code>&lt;intent-filter&gt;</code>元素内的<code>&lt;category&gt;</code>子元素对应前面说的“分类”。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　对于一个要通过<code>Category</code>检测的<code>Intent</code>对象，在<code>Intent</code>对象中所包含的每个分类，过滤器中都必须得包含，过滤器能够列出Intent中不包含的分类，但是它不能忽略<code>Intent</code>对象中的任何分类。<br>　　因此，原则上一个没有<code>category</code>的<code>Intent</code>对象应该始终通过这个检测，而不管过滤器中声明的分类。</p>
<p>　　注意：</p>
<pre><code>-  所有传递给startActivity()方法的隐式Intent对象，都会至少包含了一个android.intent.category.DEFAULT。
-  只有Intent对象的mCategorie里的所有类型都匹配成功后，才会去匹配&lt;data&gt;标签。
</code></pre><p><br><strong>Data检测</strong><br>　　像<code>Action</code>、<code>Category</code>检测一样，针对<code>IntentFilter</code>的“数据”也要包含在一个子元素中，这个子元素能够出现<code>0~n</code>次。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"audio/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　每个<code>&lt;data&gt;</code>元素能够指定<code>URI</code>和数据类型（<code>MIME</code>）对于每个<code>URI</code>部分都会有独立的属性：scheme、host、port、path。格式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;:<span class="comment">//&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>　　例如，以下URI：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.project:200/folder/subfolder/etc</span></span><br></pre></td></tr></table></figure></p>
<pre><code>-  scheme是content
-  host  是com.example.project
-  port  是200
-  path  是folder/subfolder/etc。
</code></pre><p>　　其中<code>host</code>和<code>port</code>一起构成了<code>authority</code>，如果没有指定<code>host</code>，那么<code>port</code>也会被忽略。</p>
<p><br></p>
<h3 id="开始匹配"><a href="#开始匹配" class="headerlink" title="开始匹配"></a>开始匹配</h3><p>　　范例1：新建Activity。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"org.cxy.intent.SecondActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"act.second"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　在MainActivity中书写如下跳转语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent =  <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"act.second"</span>); </span><br><span class="line"><span class="keyword">this</span>.startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  本范例并没有为Intent指定具体要跳转到哪个Activity，而是为Intent指定一个action。
-  在调用startActivity方法启动Activity时，该方法会自动为Intent对象设置一个category，即：“android.intent.category.DEFAULT”。
</code></pre><p><br>　　范例2：data匹配。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"org.cxy.intent.SecondActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"org.cxy.action.Second"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:host</span>=<span class="string">"www.cxy.com"</span> <span class="attr">android:port</span>=<span class="string">"80"</span> <span class="attr">android:path</span>=<span class="string">"/hi.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　在MainActivity中书写如下跳转语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"org.cxy.action.Second"</span>);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"http://www.cxy.com:80/hi.jsp"</span>));</span><br><span class="line"><span class="keyword">this</span>.startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  使用scheme属性匹配代码中的协议名。
-  使用host属性匹配代码中的主机名，使用此属性之前，必须要先指定scheme属性，在代码中scheme和host之间要写上“://”作为间隔。 
-  使用port属性匹配代码中的端口号，使用path属性匹配代码中的路径。
</code></pre><p><br>　　范例3：数据类型匹配。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"org.cxy.intent.SecondActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"org.cxy.action.Second"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:host</span>=<span class="string">"www.cxy.com"</span> <span class="attr">android:port</span>=<span class="string">"80"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:path</span>=<span class="string">"/hi.jsp"</span> <span class="attr">android:mimeType</span>=<span class="string">"image/gif"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　在MainActivity中书写如下跳转语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"org.cxy.action.Second"</span>);</span><br><span class="line">intent.setDataAndType(Uri.parse(<span class="string">"http://www.cxy.com:80/hi.jsp"</span>),<span class="string">"image/gif"</span>);</span><br><span class="line"><span class="keyword">this</span>.startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  使用mimeType属性可以对数据的MIME类型进行限制。
-  使用setData方法设置Intent的Uri，使用setType方法设置Intent的MIME类型。
-  但是如果你想同时设置这两者，则只能使用setDataAndType方法，因为setData和setType方法中会彼此清除对方的值，具体请查看源码。
</code></pre><p><br>　　在<code>&lt;intent-filter&gt;</code>中可以不列出<code>&lt;data&gt;</code>元素，但是只要列出了，那么<code>&lt;data&gt;</code>中所列出的所有属性都得匹配。</p>
<p><br>　　范例4：假设我们有如下配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".B"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"aa.test.BBBBBB"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　那么我们可以用如下代码进行匹配：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"aa.test.BBBBBB"</span>);</span><br><span class="line">intent.setDataAndType(Uri.parse(<span class="string">"content://abc"</span>),<span class="string">"image/png"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  也就是说，虽然我们没有为&lt;data&gt;元素设置scheme属性，但是它却存在默认值，会默认匹配“file”、“content”。
-  另外，在&lt;data&gt;元素的path和mimeType属性的值中，都可以包含通配符“*”，用来匹配0~n个任意字符。
</code></pre><p><br>　　范例5：安装应用程序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line"><span class="comment">// Uri.fromFile()方法根据文件对象的路径来构造一个Uri。</span></span><br><span class="line">intent.setDataAndType(Uri.fromFile(file),<span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  本范例使用系统内置的ACTION_VIEW动作安装APK文件。
-  ACTION_VIEW动作所要操作的数据的Uri是通过一个File对象的路径构造出来的。
-  ACTION_VIEW动作用于“查看”，该动作会根据其所要查看的数据的MIME类型的不同，来调用不同的应用程序来查看数据。
-  APK文件的MIME类型为application/vnd.android.package-archive ，而查看APK文件，其实就是安装APK文件。
</code></pre><p><br>　　范例6：卸载应用程序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_DELETE);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"package:"</span>+ <span class="keyword">this</span>.getPackageName()));</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  调用系统内置的ACTION_DELETE动作可以执行删除操作。
-  若删除的数据为：“package:应用程序包名”，则相当于卸载该应用程序。 
-  调用Activity的getPackageName()方法可以获取当前应用程序的包名称。
</code></pre><p><br>　　范例7：启动发送短信Acitivity。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="comment">// 设置意图的动作为“发送”和“发送数据”的MIME类型。</span></span><br><span class="line">intent.setAction(Intent.ACTION_SEND);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置要发送的 正文数据。</span></span><br><span class="line">intent.putExtra(Intent.EXTRA_TEXT, <span class="string">"Hi 发送短信哦!"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  程序运行时会打开系统发送短信界面。
</code></pre><p><br><strong>扩展：</strong><br>　　<code>PackageManager</code>类中有一组<code>query…()</code>以及<code>resolve…()</code>方法。<br>　　前者返回能够接受指定<code>Intent</code>对象的所有组件，后者返回最佳匹配结果（即只返回1个结果），例如：</p>
<pre><code>-  queryIntentActivities()方法返回能够执行这个Intent对象的所有Activity。
-  queryIntentServices()方法类似地返回Service列表。
-  queryBroadcastReceivers()方法类似地返回Broadcast Receiver列表。
</code></pre><p>　　这些方法都不激活组件，它们只是列出能够响应这个<code>Intent</code>对象的所有组件。</p>
<h1 id="第四节-Fragment"><a href="#第四节-Fragment" class="headerlink" title="第四节 Fragment"></a>第四节 Fragment</h1><p>　　<code>Android</code>在<code>3.0</code>中引入了<code>fragments</code>的概念，<code>Android3.0</code>是基于<code>Android</code>的平板电脑专用操作系统。</p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><br><strong>问题是这样的：</strong><br>　　在一个小屏幕的设备上，一个<code>Activity</code>通常占据了整个屏幕，其内显示各种UI视图组件。但是当一个<code>Activity</code>被显示在一个大屏幕的设备上时，例如平板，总会显得有些不适应，因为平板的屏幕太大了，UI组件会被拉长、模糊。<br>　　因此若想使<code>Activity</code>的UI组件在大屏幕中美观且充满整个屏幕，则就需要在其内添加更多的组件，但是这样一来，视图的层次结构就很复杂了。但层次结构复杂也许并不是问题的关键，对于两个功能相似的<code>Activity</code>来说，他们UI界面也会高度相仿，这也就意味着代码的重复量会大大增加（这个问题也存在于手机设备上，只不过在大屏幕设备上更为突出而已）。</p>
<p>　　因此<code>Android3.0</code>为了支持更加动态和灵活的UI设计，它引入了<code>fragments</code>的概念。</p>
<p><br><strong>是什么？</strong><br>　　解决代码冗余最好的方法就是把各功能相似的<code>Activity</code>中那块相似的部分抽取出来，然后封装成一个类，以后就可以在需要使用的时候实例化一个对象放入<code>Activity</code>即可。<br>　　在<code>Android3.0</code>中<code>Google</code>已经帮我们封装好了这个类，即<code>Fragment</code>。也就是说<code>Fragment</code>的作用就是用来封装各<code>Activity</code>中公用的组件，以便代码重用和管理。</p>
<p>　　既然已经知道了<code>Fragment</code>的作用，那么接下来说说它的特点：</p>
<pre><code>-  Fragment可以将一组View封装成一个整体，但它本身却不是继承自View类。
-  Fragment必须总是被嵌入到一个Activity中，它无法单独使用。
-  Fragment更像一个容器，它的存在就是为了将多个View打包在一起，它本身无法被直接显示。
-  Fragment有它自己的生命周期，接收属于它的输入事件，并且我们可以在Activity运行期间动态的向Activity中添加和删除Fragment。
-  Fragment的生命周期直接被其所属的宿主Activity的生命周期影响。
</code></pre><p>　<br>　　一个<code>Activity</code>中可以同时嵌入多个<code>Fragment</code>。<br>　　举个例子，你可能会仅当在屏幕尺寸足够大（平板电脑）时，在一个<code>Activity</code>中包含多个<code>Fragment</code>（如下图-左），而当不属于这种情况（手机）时则只包含一个<code>Fragment</code>（如下图-右）。</p>
<p>　　　　　　　　　<img src="/img/android/android_2_3.png" alt="Fragment"></p>
<p>　　提示：</p>
<pre><code>-  Fragment是在Android3.0中提供的，若想在Android2.x平台上使用Fragment则需要添加android-support-v4.jar库。
</code></pre><p><br>　　还有一种应用场景，比如ActionBar上有多个Tab页，切换不同的Tab页时，Activity就显示不同的布局。<br>　　在以前，我们可能会把所有布局都放到一个布局文件中，随着Tab的切换而执行setVisibility，这样做有两个问题：</p>
<pre><code>-  第一，Activity首次加载的控件很多，即便是通过延迟加载延缓解决这个问题，还有下面的问题。
-  第二，布局文件里的控件的初始化、事件监听/处理等代码都得写在Activity中，不方便管理和移动。 
   -  也许你会说，封装成一个类不久行了。
   -  是的，Fragment就是Android帮我们封装好的，我们只需要使用Fragment来实现这几个Tab的界面即可。
</code></pre><p>　　也就是说，我们并不是只有在多个界面都需要显示相同的布局时才使用Fragment，上面这种情况也应该使用Fragment。</p>
<h2 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h2><p>　　要创建一个<code>Fragment</code>类，必须让该类继承<code>Fragment</code>或其子类 。<br>　　<code>Fragment</code>类的代码看上去有点象<code>Activity</code>，它也包含了<code>onCreate()</code>、<code>onStart()</code>、<code>onPause()</code>和<code>onStop()</code>方法。</p>
<p><br><strong>创建Fragment</strong><br>　　我们已经知道<code>Fragment</code>用来作为<code>Activity</code>的用户界面的一部分，其内封装的<code>view</code>会被放入<code>Activity</code>中。<br>　　那么应该如何给<code>Fragment</code>提供一个<code>view</code>呢?<br>　　答：实现<code>Fragment</code>类的<code>onCreateView()</code>回调方法即可，该方法是<code>Fragment</code>的生命周期方法之一，当<code>Activity</code>需要<code>Fragment</code>创建它自己的<code>view</code>时，就会调用它。</p>
<p><br>　　范例1：MyFragment。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.example_fragment, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  inflater：一个工具类的对象，可以从一个XML Layout资源文件中读取并生成View。
-  container：你的Fragment将被插入的父ViewGroup(来自activity的layout)。
-  savedInstanceState：如果Fragment是被恢复的，它提供关于Fragment的之前的实例的数据。
</code></pre><p><br><strong>添加入Activity中</strong><br>　　创建完<code>Fragment</code>后，接下来就要将它添加到<code>Activity</code>中进行显示了。</p>
<pre><code>-  Fragment会嵌入到宿主Activity的View Hierarchy中，被作为Activity的整个的一部分。
</code></pre><p>　　但是由于<code>Fragment</code>本身并不是<code>View</code>的子类，我们无法通过<code>addView</code>等方法将其直接放入到<code>Actvity</code>中。<br>　　虽然如此，但是还是有<code>2</code>种方法可以添加一个<code>Fragment</code>到<code>Activity</code>中。</p>
<p><br>　　第一种，在<code>Activity</code>的<code>layout</code>文件中声明<code>&lt;fragment&gt;</code>标签，可以像<code>View</code>一样指定<code>layout</code>属性。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/myFragment"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.example.androidtest.MyFragment"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  android:name属性指定了要实例化Fragment类的名称。
-  当系统创建Activity的界面时，会依次实例化每个&lt;fragment&gt;标签，并调用它们的onCreateView()方法来获取View，然后把返回的View直接插入到&lt;fragment&gt;元素所在的地方。
</code></pre><p><br>　　第二种，在<code>Activity</code>运行的任何时候都可以通过<code>FragmentManager</code>来操作和管理<code>Fragment</code>。有两种方式可以获取到<code>FragmentManager</code>的实例：</p>
<pre><code>-  若项目的SDK版本为3.0以上，则通过Activity的getFragmentManager()方法获取。
-  若项目的SDK版本低于3.0，则通过FragmentActivity的getSupportFragmentManager()方法获取。
</code></pre><p><br>　　另外，每个<code>Fragment</code>都需要一个唯一的标识，以便在程序中引用它。有<code>3</code>种方法来为一个Fragment提供一个标识：</p>
<pre><code>-  为android:id属性提供一个唯一ID。
-  为android:tag属性提供一个唯一字符串。
-  如果以上2个你都没有提供，系统使用Fragment所在的容器view的ID。
</code></pre><p><br>　　范例1：添加Fragment。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 添加Fragment</span></span><br><span class="line">        MyFragment f = <span class="keyword">new</span> MyFragment();</span><br><span class="line">        <span class="comment">// FragmentManager和FragmentTransaction后面介绍。</span></span><br><span class="line">        FragmentManager mgr = getSupportFragmentManager();</span><br><span class="line">        FragmentTransaction trans = mgr.beginTransaction();</span><br><span class="line">        trans.add(R.id.layout,f);</span><br><span class="line">        trans.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  由于Android3.0之前的Activity类不支持Fragment这个类，因此在android-support-v4.jar中Google使用FragmentActivity来对Activity的功能进行了增强。若你项目的SDK版本低于Android3.0，则需要添加android-support-v4.jar包，并且要让你的Activity继承FragmentActivity类。
-  本范例是通过继承FragmentActivity类来实现的。执行完毕编辑操作后，若不调用commit()方法则事务是永远不会生效的。
</code></pre><p><br>　　范例2：FragmentManager类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentManager</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启一个事务，之后对Fragment的操作都是在这个事务对象进行的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FragmentTransaction <span class="title">beginTransaction</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定Fragment的id或tag，从当前FragmentManager对象中查找出Fragment对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Fragment <span class="title">findFragmentById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Fragment <span class="title">findFragmentByTag</span><span class="params">(String tag)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  不论是Android3.0之后的Activity类还是FragmentActivity类，在它们的内部都定义了一个FragmentManager类型的属性，它管理着所有嵌入到其宿主Activity内的Fragment对象。
-  由于一个Activity中可以嵌入多个Fragment，为了方便高效的编辑这些Fragment对象，Android采用了“事务提交”的方式。
-  每当需要编辑Activity中的某个Fragment时，都要先开启一个事务。然后在事务对象上执行编辑操作(如add、remove、replace等)，执行完毕所有的编辑后再一次性的提交给Activity去更新界面。
</code></pre><p><br>　　范例3：FragmentTransaction类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentTransaction</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数fragment对象添加到Activity的布局中containerViewId组件下。</span></span><br><span class="line">    <span class="comment">// containerViewId所指向的组件必须是ViewGroup类型的，否则抛异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FragmentTransaction <span class="title">add</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除containerViewId下面的fragment对象，然后将参数fragment对象放到containerViewId下面。</span></span><br><span class="line">    <span class="comment">// 若containerViewId下面有多个fragment对象，则删除最先找到的那个。</span></span><br><span class="line">    <span class="comment">// tag：为参数fragment指定的tag。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FragmentTransaction <span class="title">replace</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用此方法相当于调用其重载方法replace(containerViewId, fragment,null) 即参数tag的值为null。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FragmentTransaction <span class="title">replace</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务。</span></span><br><span class="line">    <span class="comment">// 事务中包含的操作不会立刻生效，事务会被放入到创建当前事务对象的FragmentManager对象所在Activity类的mHandler</span></span><br><span class="line">    <span class="comment">// 属性中，等待被主线程处理。但你可以从你的UI线程调用executePendingTransactions()来立即执行由commit()提交的事</span></span><br><span class="line">    <span class="comment">// 务. 但这么做通常不必要,除非事务是其他线程中的job的一个从属。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　<code>trans.add(R.id.layout,f)</code>将<code>Fragment</code>对象添加到<code>Activity</code>的组件下，此语句等价于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup container = (ViewGroup)activity.findViewById(R.id.layout);</span><br><span class="line">container.addView(f.mView);</span><br></pre></td></tr></table></figure></p>
<p>　　其中<code>f.mView</code>就是Fragment内部所封装的View。</p>
<p><br><strong>事务回滚</strong><br>　　事务是支持回滚的，即撤销上一步操作。<br>　　在<code>FragmentManager</code>中维护了一个<code>事务栈</code>。我们可以在事务对象提交(<code>commit</code>)之前，设置是否要将该事务放在事务栈中。 当用户在<code>Activity</code>中按下<code>back</code>键时，会撤销栈顶的事务所做出的修改。</p>
<p><br>　　范例1：添加Fragment。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        FragmentManager mgr = getSupportFragmentManager();</span><br><span class="line">        MyFragment f = <span class="keyword">new</span> MyFragment();</span><br><span class="line">        FragmentTransaction trans = mgr.beginTransaction();</span><br><span class="line">        trans.add(R.id.layout, f);</span><br><span class="line">        trans.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line">        trans.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  本范例添加了一个Fragment，并调用addToBackStack()方法来标识事务对象需要被加入事务栈。
-  当BACK键被按下时Fragment就会被从Activity中移除，并将该事务从栈中移除。当事务栈为空时，Activity将不会再拦截BACK键事件。
-  如果添加多个变化到事务(例如add()或remove())并调用addToBackStack()，然后在你调用commit()之前的所有应用的变化会被作为一个单个事务添加到后台堆栈，BACK按键会将它们一起回退。
</code></pre><p><br>　　范例2：替换Fragment。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        FragmentManager mgr = getSupportFragmentManager();</span><br><span class="line">        <span class="comment">// 第一个fragment。</span></span><br><span class="line">        MyFragment f = <span class="keyword">new</span> MyFragment(<span class="string">"AA"</span>);</span><br><span class="line">        FragmentTransaction trans = mgr.beginTransaction();</span><br><span class="line">        trans.add(R.id.layout, f);</span><br><span class="line">        trans.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line">        trans.commit();</span><br><span class="line">        <span class="comment">// 第二个fragment。		</span></span><br><span class="line">        MyFragment f2 = <span class="keyword">new</span> MyFragment(<span class="string">"BB"</span>);</span><br><span class="line">        FragmentTransaction trans2 = mgr.beginTransaction();</span><br><span class="line">        trans2.add(R.id.layout, f2);</span><br><span class="line">        trans2.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line">        trans2.commit();</span><br><span class="line">        <span class="comment">// 第三个fragment。</span></span><br><span class="line">        MyFragment f3 = <span class="keyword">new</span> MyFragment(<span class="string">"CC"</span>);</span><br><span class="line">        FragmentTransaction trans3 = mgr.beginTransaction();</span><br><span class="line">        trans3.replace(R.id.layout, f3);</span><br><span class="line">        trans3.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line">        trans3.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  如果添加多个Fragment到同一个容器，那么添加的顺序决定了它们在view hierarchy中显示的顺序。 因此f会被放到f2的前面显示。
-  本范例使用replace方法会将f给删除，并将f3添加到R.id.layout的末尾位置。
-  本范例的三个事务都被加入到事务栈中，当第一次按下BACK键时，f3会被移除，f会被还原。 注意：f会被还原到f3的位置，而不是f2的前面。也就是说，对于addToBackStack()方法，它只会记录fragment的操作，而不会记录fragment当时的位置。当执行还原的时候，会将fragment放到containerView的末尾。
</code></pre><p><br>　　范例3：删除Fragment。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        FragmentManager mgr = getSupportFragmentManager();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...  此处省略了范例2中的代码。</span></span><br><span class="line"></span><br><span class="line">        FragmentTransaction trans4 = mgr.beginTransaction();</span><br><span class="line">        trans4.remove(f);</span><br><span class="line">        trans4.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line">        trans4.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  当按下BACK键时，f会被还原。即f会被还原到f3的后面，而不是f2的前面。
-  对于每一个Fragment事务，你可以应用一个事务动画，通过在提交事务之前调用setTransition()实现。
</code></pre><p><br><strong>为Activity创建事件回调方法</strong><br>　　在一些情况下，你可能需要一个<code>Fragment</code>与<code>Activity</code>分享事件。<br>　　例如，<code>Activity</code>中有<code>2</code>个<code>Fragment</code>，一个用来显示文章列表(<code>A</code>)，另一个显示文章内容(<code>B</code>)。 当用户点击了<code>A</code>中的某个文章时，<code>A</code>就告诉宿主<code>Activity</code>，然后宿主<code>Activity</code>就可以转告诉<code>B</code>去显示文章。</p>
<p><br>　　范例1：定义回调接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentA</span> <span class="keyword">extends</span> <span class="title">ListFragment</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Container Activity must implement this interface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnArticleSelectedListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArticleSelected</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OnArticleSelectedListener mListener;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(activity);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mListener = (OnArticleSelectedListener) activity;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(activity.toString() + <span class="string">" must implement OnArticleSelectedListener"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l,View v,<span class="keyword">int</span> position,<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Send the event and Uri to the host activity</span></span><br><span class="line">        mListener.onArticleSelected(position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  让FragmentA的宿主Activity实现OnArticleSelectedListener接口，并覆写抽象方法。
-  当onArticleSelected()被调用时，宿主Activity就可以通知FragmentB，并将FragmentA传来的数据转给FragmentB。
-  为了确保宿主Activity实现这个接口，在onAttach()方法被调用 (此方法是生命周期方法之一，后述) 时，可以将onAttach()的参数做类型转换来实例化一个OnArticleSelectedListener实例。
-  若宿主Activity没有实现接口，则Fragment就会抛出ClassCastException异常。
-  由于FragmentA是ListFragment的子类，因此每次用户点击一个列表项，系统调用在Fragment中的onListItemClick()，然后后者调用onArticleSelected()来分配事件给Activity。
</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>　　<code>Fragment</code>有自己的生命周期，并且生命周期直接被其所属的宿主<code>Activity</code>的生命周期影响。当<code>Activity</code>被暂停，那么在其中的所有<code>Fragment</code>也被暂停，当<code>Activity</code>被销毁，所有隶属于它的<code>Fragment</code>也被销毁。</p>
<p>　　管理<code>Fragment</code>的生命周期，大多数地方和管理<code>Activity</code>生命周期很像，和<code>Activity</code>一样。<br>　　<code>Fragment</code>生命周期各个阶段回调的方法如下图(左)，<code>Fragment</code>和<code>Activity</code>的生命周期方法对应关系图(右)：<br>　　　　　　　<img src="/img/android/android_2_4.png" alt="">　　　　　<img src="/img/android/android_2_5.png" alt=""><br>　　和<code>Activity</code>一样，你可以使用<code>Bundle</code>保持<code>Fragment</code>的状态，万一<code>Activity</code>的进程被干掉，并且当<code>Activity</code>被重新创建的时候，你需要恢复<code>Fragment</code>的状态时就可以用到。<br>　　在<code>Fragment</code>的<code>onSaveInstanceState()</code>期间保存状态，并可以在<code>onCreate()</code>，<code>onCreateView()</code>或<code>onActivityCreated()</code>期间恢复它。</p>
<p><br><strong>各生命周期方法的调用</strong></p>
<pre><code>-  onAttach：当Fragment通过事务对象被绑定到Activity时被调用(宿主Activity的引用会被传入)。在onAttach方法被调用后，其宿主Activity的onAttachFragment方法将被调用。
-  onCreate：通常情况下，在宿主Activity的onAttachFragment方法将被调用后，会调用Fragment的onCreate方法。
-  onCreateView：不论Fragment的onCreate是否调用，都将继续调用onCreateView方法，此方法需要返回Fragment内封装的view的根节点。
-  onActivityCreated：若Activity的onCreate方法已经返回，则此方法将会在onCreateView方法被调用后被调用。
-  onStart、onResume、onPause、onStop：这四个方法的调用情形与Activity一样。
-  onDestroyView：当和Fragment关联的view hierarchy被移除之前会调用此方法，此方法返回后就会执行移除操作。
-  onDestroy：当Fragment被销毁时被调用。
-  onDetach：当Fragment与宿主Activity解除关联时被调用。
</code></pre><h2 id="销毁重建"><a href="#销毁重建" class="headerlink" title="销毁重建"></a>销毁重建</h2><p>　　<code>Fragment</code>的生命周期受其宿主<code>Activity</code>的影响，当宿主<code>Activity</code>因为某种原因被摧毁(如手机横竖屏切换、内存不足导致后台<code>Activity</code>被回收等)，且用户再次导航回来时，接着宿主<code>Activity</code>就会执行重建操作，其内部的各个<code>Fragment</code>也会跟随着它执行重建。</p>
<p>　　<code>Activity</code>的重建，简单的说就是重新实例化一个对象，并将之前被摧毁的对象的各种状态设置到新的对象上，关于重建这一点<code>Fragment</code>和其宿主<code>Activity</code>的操作是一样的。此时就存在一个问题，重建的操作是系统来完成的，而重建又需要创建新的对象，那么操作系统是如何实例化我们自己定义的<code>Fragment</code>类的呢?<br>　　答案就是：通过<code>反射机制</code>。</p>
<p>　　由于通常我们创建自己的类时会依据需要自定义若干个构造方法，而操作系统在重建时只会调用无参的构造器(因为有参的构造器所需要的参数，操作系统是不可以自主的随便提供的，否则程序就乱套了)。<br>　　因此我们要保证自定义的<code>Fragment</code>类必须要有一个无参的构造方法，以便系统对其重建时调用。<br><br>　　找到<code>Fragment</code>类看到如下代码：<br>　　　　　<img src="/img/android/android_2_6.png" alt="Fragment类代码片段"><br>　　上面的源码也可以证实，必须要为<code>Fragment</code>提供一个无参的构造方法。<br>　　其实<code>Activity</code>也需要无参的构造方法，只是由于它的实例由操作系统来创建，所以我们以前并没有涉及到此问题。</p>
<p><br><strong>实例化的方法</strong><br>　　现在我们又遇到一个问题： 很多时候我们需要在实例化<code>Fragment</code>的同时为其传递一些参数，而系统在重建<code>Fragment</code>时只会调用无参的构造方法，也就跳过传参的这一步骤，这必然会导致程序出问题。<br>　　这该怎么解决呢?<br><br>　　这个问题<code>Fragment</code>已经替我们考虑到了，<code>Fragment</code>类有一个属性名为<code>mArguments</code>，它是<code>Bundle</code>类型的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Construction arguments;</span><br><span class="line">Bundle mArguments;</span><br></pre></td></tr></table></figure></p>
<p>　　当我们构造<code>Fragment</code>对象时，可以将需要传递给<code>Fragment</code>的参数放到这个<code>Bundle</code>对象中。这样即便是随后<code>Fragment</code>对象被摧毁了也没关系，因为系统会将<code>Fragment</code>的<code>mArguments</code>属性的值保存起来，当重建的时候也会将<code>mArguments</code>属性的值给还原。<br><br>　　因此对于<code>Fragment</code>的初始化操作，我们通常的写法是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        FragmentTransaction trans = getSupportFragmentManager().beginTransaction();</span><br><span class="line">        trans.add(R.id.rootView, MyFragment.getInstance(<span class="string">"Hi World"</span>));</span><br><span class="line">        trans.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：MyFragment。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String property;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyFragment <span class="title">getInstance</span><span class="params">(String property)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们也调用无参构造方法。</span></span><br><span class="line">        MyFragment f = <span class="keyword">new</span> MyFragment();</span><br><span class="line">        Bundle data = <span class="keyword">new</span> Bundle();</span><br><span class="line">        data.putString(<span class="string">"property"</span>, property);</span><br><span class="line">        <span class="comment">// 将参数设置到MyFragment中。</span></span><br><span class="line">        f.setArguments(data);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 当MyFragment被创建时，读取参数。</span></span><br><span class="line">        property = getArguments().getString(<span class="string">"property"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        TextView text = <span class="keyword">new</span> TextView(inflater.getContext());</span><br><span class="line">        text.setText(property);</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  前面说了Activity重建的时候是通过反射机制来实例化每个Fragment的。因此我们自定义的Fragment类必须是public修饰的。并且若Fragment是某个类的内部类，则其还必须是static的。
</code></pre><p><br><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="http://www.eoeandroid.com/thread-71642-1-1.html" target="_blank" rel="noopener">Fragments (Android官方文档中文版)</a></li>
<li><a href="http://blog.csdn.net/aomandeshangxiao/article/details/7671533" target="_blank" rel="noopener">Android之Fragment（官网资料翻译）</a></li>
</ul>
<p><br><br></p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechatpay.jpg" alt="乐信圣文 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/language-B02/" rel="next" title="Cocos2dx篇　第二章 Lua 程序设计">
                <i class="fa fa-chevron-left"></i> Cocos2dx篇　第二章 Lua 程序设计
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/android-A03/" rel="prev" title="入门篇　第二章 服务与广播接收者">
                入门篇　第二章 服务与广播接收者 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="android-A02/"
     data-title="入门篇　第一章 Activity"
     data-content=""
     data-url="http://yoursite.com/android-A02/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="android-A02/"
           data-title="入门篇　第一章 Activity" data-url="http://yoursite.com/android-A02/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="乐信圣文" />
          <p class="site-author-name" itemprop="name">乐信圣文</p>
          <p class="site-description motion-element" itemprop="description">集大家之成，悟小家之道。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">51</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="http://www.gov.cn/" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://weishu.me/" title="weishu" target="_blank">weishu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://ryanhoo.github.io/" title="ryanhoo" target="_blank">ryanhoo</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一节-生命周期"><span class="nav-number">1.</span> <span class="nav-text">第一节 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#正常生命周期"><span class="nav-number">1.1.</span> <span class="nav-text">正常生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常生命周期"><span class="nav-number">1.2.</span> <span class="nav-text">异常生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设备配置改变"><span class="nav-number">1.2.1.</span> <span class="nav-text">设备配置改变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态保存"><span class="nav-number">1.2.2.</span> <span class="nav-text">状态保存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二节-Task"><span class="nav-number">2.</span> <span class="nav-text">第二节 Task</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识"><span class="nav-number">2.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动模式"><span class="nav-number">2.2.</span> <span class="nav-text">启动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用清单文件"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用清单文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Intent"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用Intent</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三节-Intent"><span class="nav-number">3.</span> <span class="nav-text">第三节 Intent</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#显式意图"><span class="nav-number">3.1.</span> <span class="nav-text">显式意图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式意图"><span class="nav-number">3.2.</span> <span class="nav-text">隐式意图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IntentFilter类"><span class="nav-number">3.2.1.</span> <span class="nav-text">IntentFilter类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始匹配"><span class="nav-number">3.2.2.</span> <span class="nav-text">开始匹配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四节-Fragment"><span class="nav-number">4.</span> <span class="nav-text">第四节 Fragment</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景介绍"><span class="nav-number">4.1.</span> <span class="nav-text">背景介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本应用"><span class="nav-number">4.2.</span> <span class="nav-text">基本应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生命周期"><span class="nav-number">4.3.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#销毁重建"><span class="nav-number">4.4.</span> <span class="nav-text">销毁重建</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乐信圣文</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cutler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("sGcgYofeKOFi2l1XvGrm0PcP-gzGzoHsz", "Sx0mWxj4pkXYm17zT0UnV5Ca");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
