<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="http://www.gov.cn/" title="乐信圣文" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="本章将从源码的角度来介绍一下操作系统、进程和四大组件的启动过程。本章第3~6节主要参考《Android开发艺术探索》。 　　在开始讲解知识之前，笔者有下面四点要说： -  第一，本文只分析Java层的代码，不包含C++层的代码。 -  第二，请各位一定要跟随笔者描述的步骤去看一遍源码，否则阅读本文时会朦胧。 -  第三，由于篇幅有限以及阅读方便，本文中列出的源码都是笔者简化后的，请自行查看完整">
<meta property="og:type" content="article">
<meta property="og:title" content="Framework篇 第三章 系统、进程、四大组件启动过程">
<meta property="og:url" content="http://yoursite.com/android-framework-003/index.html">
<meta property="og:site_name" content="乐信圣文">
<meta property="og:description" content="本章将从源码的角度来介绍一下操作系统、进程和四大组件的启动过程。本章第3~6节主要参考《Android开发艺术探索》。 　　在开始讲解知识之前，笔者有下面四点要说： -  第一，本文只分析Java层的代码，不包含C++层的代码。 -  第二，请各位一定要跟随笔者描述的步骤去看一遍源码，否则阅读本文时会朦胧。 -  第三，由于篇幅有限以及阅读方便，本文中列出的源码都是笔者简化后的，请自行查看完整">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/android/android_BY_c02_02.jpg">
<meta property="og:image" content="http://yoursite.com/img/android/android_BY_c02_01.jpg">
<meta property="og:updated_time" content="2020-01-20T07:20:16.682Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Framework篇 第三章 系统、进程、四大组件启动过程">
<meta name="twitter:description" content="本章将从源码的角度来介绍一下操作系统、进程和四大组件的启动过程。本章第3~6节主要参考《Android开发艺术探索》。 　　在开始讲解知识之前，笔者有下面四点要说： -  第一，本文只分析Java层的代码，不包含C++层的代码。 -  第二，请各位一定要跟随笔者描述的步骤去看一遍源码，否则阅读本文时会朦胧。 -  第三，由于篇幅有限以及阅读方便，本文中列出的源码都是笔者简化后的，请自行查看完整">
<meta name="twitter:image" content="http://yoursite.com/img/android/android_BY_c02_02.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/android-framework-003/"/>

  <title> Framework篇 第三章 系统、进程、四大组件启动过程 | 乐信圣文 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?53b4b0b5aeb5df5e4fb6263a58d8e1a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">乐信圣文</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feedback">
          <a href="/feedback" rel="section">
            
            联系我们
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Framework篇 第三章 系统、进程、四大组件启动过程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            
              <span class="post-meta-item-text">Cutler</span>
            
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-30T18:05:12+08:00" content="2016-03-30">
              2016-03-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-03-高级开发/" itemprop="url" rel="index">
                    <span itemprop="name">Android - 03 - 高级开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          

          
          
             <span id="/android-framework-003/" class="leancloud_visitors" data-flag-title="Framework篇 第三章 系统、进程、四大组件启动过程">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>　　本章将从源码的角度来介绍一下操作系统、进程和四大组件的启动过程。本章第<code>3~6</code>节主要参考<a href="http://item.jd.com/1710650057.html" target="_blank" rel="noopener">《Android开发艺术探索》</a>。</p>
<p>　　在开始讲解知识之前，笔者有下面四点要说：</p>
<pre><code>-  第一，本文只分析Java层的代码，不包含C++层的代码。
-  第二，请各位一定要跟随笔者描述的步骤去看一遍源码，否则阅读本文时会朦胧。
-  第三，由于篇幅有限以及阅读方便，本文中列出的源码都是笔者简化后的，请自行查看完整源码。
-  第四，如果您之前没接触过Framework层的话，那么本文您至少需要读两遍。
</code></pre><a id="more"></a>
<h1 id="第一节-系统的启动"><a href="#第一节-系统的启动" class="headerlink" title="第一节 系统的启动"></a>第一节 系统的启动</h1><p>　　<code>Android</code>是基于<code>Linux</code>的开源操作系统，它的启动过程与<code>Linux</code>有很多相似的地方。</p>
<p>　　本节就来介绍一下它的启动过程。</p>
<h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><p>　　当你按下电源开关后，Android设备执行了如下图所示的几个步骤：</p>
<center><br><img src="/img/android/android_BY_c02_02.jpg" alt=""><br></center>

<p><br>　　我们按照上图的顺序，看一下前四个操作：</p>
<pre><code>-  首先，Android设备上电后，会先启动ROM，并寻找Bootloader代码，将它加载到内存。
-  然后，执行Bootloader，然后再找到Linux内核代码，并将它加载到内存。
-  接着，启动Linux内核，即初始化各种软硬件环境，加载驱动程序，挂载根文件系统。
-  最后，由内核启动init进程，它是整个系统第一个启动的进程，也是所有进程的父进程。
   -  需要知道的是，init进程是Android启动过程中最核心的程序。
   -  Android系统以及各大Linux的发行版，内核部分启动过程都是差不多的，区别就在于init进程的不同。
   -  因为init进程决定了系统在启动过程中，究竟会启动哪些守护进程和服务，以及呈现出怎样的UI界面。
</code></pre><p><br>　　其实前三步没什么好说的，我们只关注第四步中提到的<code>init</code>进程，它主要做了如下三件事：</p>
<pre><code>-  第一，是挂载目录，比如挂载/sys、/dev等目录。
-  第二，运行init.rc脚本，一系列的Android服务在这时被启动起来。
   -  这一步是最重要的，因为系统所有的功能都是依赖这些服务来完成的。比如拨打电话，使用WIFI等等。
   -  只要这些服务都能正常地启动起来并且正常工作，整个Android系统也就完成了自己的启动。
-  第三，在设备的屏幕上显示出“Android”logo了。
</code></pre><p><br>　　事实上<code>init</code>进程启动的服务，可以划分为两类：一类是<code>本地服务</code>，另一类是<code>Android服务</code>。</p>
<p><br>　　<strong>本地服务</strong></p>
<pre><code>-  本地服务是指运行在C++层的系统守护进程，它又分为两部分：
   -  一部分是init进程直接启动的，如ueventd、servicemanager、debuggerd、rild、mediaserver等。
   -  另一部分是由本地服务进一步创建的，如mediaserver服务会启动AudioFlinger等本地服务。
-  注意，每一个由init直接启动的本地服务都是一个独立的Linux进程，我们通过adb shell命令查看这些本地进程。
</code></pre><p><br>　　<strong>Android服务</strong></p>
<pre><code>-  Android服务是指运行在Dalvik虚拟机进程中的服务。
-  init进程会创建Zygote进程，它是第一个Android进程，所有后续的Android应用程序都是由它fork出来的。
</code></pre><h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h2><p>　　我们都知道，每一个App其实都是：</p>
<pre><code>-  一个单独的dalvik虚拟机
-  一个单独的进程
</code></pre><p>　　为了实现资源共用和更快的启动速度，系统使用如下方式来开启新进程：</p>
<pre><code>-  每当要为App启动新进程时，都会fork（拷贝）一下zygote进程，并把fork出来的新进程做为App进程。
-  也就是说，其他应用所在的进程都是Zygote的子进程。
-  这就是将Zygote进程称为“受精卵”的原因，因为它确实和受精卵一样，能快速的分裂，并且产生遗传物质一样的细胞！
</code></pre><p><br>　　既然<code>Zygote</code>进程这么重要，那么我们就来看看它是如何被系统启动的。</p>
<p><br>　　我们忽略<code>C++</code>层的代码，系统最开始调用的<code>Java</code>层代码是<code>ZygoteInit.main()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true</span></span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Socket的服务端，以便外界可以通过Socket技术来给当前Zygote进程发送数据。</span></span><br><span class="line">        registerZygoteSocket(socketName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动一些系统服务。</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            <span class="comment">// 在操作系统中通常会提供一些公共的功能，让系统中的所有App共同访问，比如：</span></span><br><span class="line">            <span class="comment">// ActivityManagerService（简称AMS）、PackageManagerService、WindowManagerService等。</span></span><br><span class="line">            <span class="comment">// 如果你没见过它们也没关系，暂时只需要知道它们都是公有的类就可以了，它们的功能稍后会介绍。</span></span><br><span class="line">            <span class="comment">// 既然是共用的，那么它们就应该存在一个单独的进程中，这样每个APP进程就可以通过IPC方式访问它们了。</span></span><br><span class="line">            <span class="comment">// 这个单独的进程是确实存在的，名字就叫SystemServer，上面的三个类都是运行在SystemServer进程中的。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面这行代码就是用来启动SystemServer进程的。</span></span><br><span class="line">            startSystemServer(abiList, socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个死循环，不断的监听是否有人给自己发数据。</span></span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line">        <span class="comment">// 关闭Socket。</span></span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从上面的代码可以看到，当Zygote进程启动的时候，会先执行一些初始化操作，并调用startSystemServer方法创建服务。
-  然后，它就开始进行无限的循环中了，循环监听Socket。
</code></pre><p><br>　　我们接着来看看<code>Zygote</code>进程在<code>startSystemServer</code>方法中是如何启动<code>SystemServer</code>进程的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">"--setuid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgid=1000"</span>,</span><br><span class="line">    <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007"</span>,</span><br><span class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"--runtime-args"</span>,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在forkSystemServer方法内部会调用本地方法，执行fork进程的操作。</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 笔者猜测，系统在fork Zygote进程时，是完完整整的拷贝。</span></span><br><span class="line">    <span class="comment">// 也就是说，fork进程不光会拷贝进程的空间，还会拷贝进程的当前方法调用栈。</span></span><br><span class="line">    <span class="comment">// 换句话说，下面这个if代码，在Zygote进程以及Zygote的子进程都会执行。</span></span><br><span class="line">    <span class="comment">// 但是只有Zygote的子进程中，变量pid的值才是0，即只有子进程会执行下面的if里的代码。</span></span><br><span class="line">    <span class="comment">// 而Zygote进程会直接返回true，然后进入到我们前面说的那个无限循环里去，继续监听Socket了。</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程会接着执行下面的方法，注意它的参数parsedArgs，其实是对args的封装。</span></span><br><span class="line">        <span class="comment">// 而args的最后一个元素的值是：com.android.server.SystemServer，我们稍后会用到它。</span></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  虽然从上面代码中可以看到fork了SystemServer进程，但是并没有看到AMS等类被初始化。
-  那么它们是在何时初始化的呢？ 别着急，马上就告诉你。
</code></pre><p><br>　　接着来看<code>handleSystemServerProcess</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还记得Zygote进程一开始打开的那个Socket服务端吗？</span></span><br><span class="line">    <span class="comment">// 由于SystemServer进程并不需要那个功能，所以下面的代码就是用来把Socket给关掉的。</span></span><br><span class="line">    closeServerSocket();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续调用其他方法，执行初始化操作。</span></span><br><span class="line">    RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should never reach here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  第7行代码的出现，能从侧面证明，笔者在上面的猜测应该是对的。
</code></pre><p><br>　　那么我们来看一下<code>RuntimeInit</code>的<code>zygoteInit</code>的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">    redirectLogStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Java层的初始化操作，比如设置异常捕获器Thread.setDefaultUncaughtExceptionHandler等。</span></span><br><span class="line">    commonInit();</span><br><span class="line">    <span class="comment">// 执行C++层的初始化操作，比如初始化Binder对象，便于以后进行IPC操作。</span></span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    <span class="comment">// 应用程序相关的初始化，比如虚拟机相关、Target SDK版本等等。</span></span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line"></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行进程的入口函数，其实就是调用SystemServer的main方法。</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  上面第27行代码中的args.startClass其实就是之前我们提到的com.android.server.SystemServer。
</code></pre><p><br>　　接着来看一下<code>invokeStaticMain</code>方法，其实在该方法中使用了一个小技巧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    Class&lt;?&gt; cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">    Method m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">     * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">     * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">     * up the process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在方法的最后抛出一个异常，并把m放到了异常中。
-  这个异常最终会被ZygoteInit.main方法捕获，然后再去调用SystemServer类的main函数。
-  为什么要这样做呢？注释里面已经讲得很清楚了，它是为了清理堆栈的，这样就会让SystemServer类的main函数觉得自己是进程的入口函数，而事实上，在执行它之前已经做了大量的工作了。
</code></pre><p><br>　　我们看看<code>ZygoteInit.main</code>函数在捕获到这个异常的时候做了什么事：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处省略若干代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">    caller.run();</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">    closeServerSocket();</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处省略若干代码</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  直接调用了MethodAndArgsCaller的run方法，而run方法里的内容也就不言而喻了。
-  至此应该可以彻底证实笔者的猜测了：系统在fork Zygote进程时，是完完整整的拷贝，不光会拷贝进程的空间，还会拷贝进程的当前方法调用栈。
</code></pre><p><br>　　既然程序的流程走到了<code>SystemServer.main</code>方法中，那么我就来看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the system service manager.</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化AMS、PMS等类。</span></span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        <span class="comment">// 初始化WMS等类。</span></span><br><span class="line">        startOtherServices();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启轮询。</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  可以看到，SystemServer初始化完各类服务之后，自己也通过Looper进入无限循环了。
</code></pre><p><br>　　至此，整个开机流程算是简单的过了一遍了，等我们进入<code>“黄金分段”</code>的时候，也许会进一步深入。</p>
<p><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="noopener">【凯子哥带你学Framework】Activity启动过程全解析</a></li>
<li><a href="http://ticktick.blog.51cto.com/823160/1659473" target="_blank" rel="noopener">Android内核开发：图解Android系统的启动过程</a></li>
</ul>
<h1 id="第二节-进程的启动"><a href="#第二节-进程的启动" class="headerlink" title="第二节 进程的启动"></a>第二节 进程的启动</h1><p><br><strong>初识AMS</strong></p>
<p>　　当手机开机时，操作系统会分别在<code>C/C++</code>和<code>java</code>层中启动很多服务。</p>
<p>　　其中就有一个<code>Java</code>层的组件，它运行在<code>SystemServer</code>进程里的，名为<code>ActivityManagerService</code>（简称<code>AMS</code>）。</p>
<pre><code>-  AMS有很多功能，后面我们会一一介绍，此处会涉及到它其中一个功能，就是为Android应用程序创建新的进程。
-  即当用户请求启动四大组件时，系统会先检测该组件所在的进程是否已经启动。
-  如果没有启动，则就会调用AMS去创建一个新的进程，然后在这个新的进程中启动该组件。
</code></pre><p><br>　　当<code>AMS</code>需要启动新的进程时，会调用自己的<code>startProcessLocked</code>方法（至于该方法是被谁调用的，第三节再说）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> uid = app.uid;</span><br><span class="line">    <span class="keyword">int</span>[] gids = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entryPoint == <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">        app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">        app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">        app.info.dataDir, entryPointArgs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  首先，startProcessLocked方法执行了一些操作之后，转调用了Process.start函数去创建进程。
-  需要注意的是，此时传递给Process.start方法的第一个参数的值是android.app.ActivityThread。
   -  ActivityThread是用户进程初始化时要加载的入口Java类，而且它就是我们常说的主线程，具体后述。
</code></pre><p><br>　　在<code>Process</code>的<code>start</code>方法内部，又经历了如下几个调用：</p>
<pre><code>-  接着调用了Process的startViaZygote方法。
-  接着调用了Process的openZygoteSocketIfNeeded方法，并在该方法中打开一个连接到Zygote进程的Socket。
-  接着调用了Process的zygoteSendArgsAndGetResult方法，并将一些参数写入到刚才打开的那个Socket中。
</code></pre><p><br>　　这样一来，程序的流程就从<code>SystemServer</code>进程中的<code>AMS</code>中转到了<code>Zygote</code>进程中了。</p>
<p>　　在第一节中已经说了，这个<code>Socket</code>由<code>ZygoteInit</code>类的<code>runSelectLoopMode</code>函数侦听，我们来看一下它的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 使用peers.get(i)得到的是一个ZygoteConnection对象，表示一个Socket连接。</span></span><br><span class="line">                <span class="comment">// 接着调用它的runOnce方法，从Socket中读取数据。</span></span><br><span class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  因此，接下来就是调用ZygoteConnection.runOnce方法进一步处理了。
</code></pre><p><br>　　接着看一下<code>runOnce</code>方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行创建进程的操作</span></span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">            parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">            parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">            parsedArgs.appDataDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">            <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  有Linux开发经验的读者从forkAndSpecialize方法的名字就能看出它会创建一个进程。
-  这个方法有两个返回值，一个是在当前进程中返回的，一个是在新创建的子进程中返回。
-  在当前进程中的返回值就是新创建的子进程的pid值，而在子进程中的返回值是0，就跟之前一样，此时Zygote进程会继续监听Socket，而子进程则继续往下执行。
-  我们沿着子进程的执行路径继续看下去，看到了在handleChildProc方法中又调用了RuntimeInit.zygoteInit方法。
</code></pre><p><br>　　在第一节中，我们已经分析过<code>RuntimeInit</code>的<code>zygoteInit</code>方法了，它会抛出异常并被<code>main</code>方法捕获，此处就不再冗述。</p>
<p>　　经历了一番干柴烈火，程序流程终于走到了我们的主线程<code>ActivityThread</code>类中了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前线程中创建Looper对象。</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动Looper，此后主线程只在消息队列里处理消息了。</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  需要知道的是，ActivityThread本身并不是一个线程，在它内部有一个Handler类型的mH属性，用来接收外界传来的消息。
-  这个mH属性就是使用的上面第5行代码所创建的Looper对象。
-  通过观察可以发现，mH属性是实例的，这意味着只有在程序执行上面第7行代码时，mH才会被创建，而Looper对象是在第5行代码就创建，所以不会有问题。
</code></pre><p><br>　　进程启动过程的源代码，我们就先分析到这里，更多的步骤咱们以后再慢慢谈。</p>
<p>　　最后请记住：</p>
<pre><code>-  我们的App、AMS以及zygote进程分属于三个独立的进程。
-  App与AMS通过Binder进行IPC通信，AMS(在SystemServer进程中)与zygote通过Socket进行IPC通信。
</code></pre><p><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6747696" target="_blank" rel="noopener">Android应用程序进程启动过程的源代码分析</a></li>
</ul>
<h1 id="第三节-Activity的启动"><a href="#第三节-Activity的启动" class="headerlink" title="第三节 Activity的启动"></a>第三节 Activity的启动</h1><p>　　既然要介绍Activity的启动流程，那么肯定要从<code>startActivity</code>方法开始了。</p>
<p><br>　　在开始之前需要知道两点：</p>
<pre><code>-  第一，startActivity方法最初是在Context类定义的，但在Activity类中对它进行了重写。
-  第二，在Activity中提供了好几个startActivity方法重载，不过它们最终都会调用startActivityForResult方法。
</code></pre><p><br>　　因此，我们就直接来看看<code>startActivityForResult</code>的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前Activity不是ActivityGroup的子Activity的话，则执行if里的代码。</span></span><br><span class="line">    <span class="comment">// 我们以前常用ActivityGroup来实现Tab切换界面，它在API level 13中被废弃了，具体请自行搜索。</span></span><br><span class="line">    <span class="comment">// 所以我们接下来只关心if里面的代码。</span></span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 下面的代码会调用Instrumentation的execStartActivity方法执行启动任务。</span></span><br><span class="line">        <span class="comment">// 至于Instrumentation是什么，稍后介绍。</span></span><br><span class="line">        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  需要注意的是第10行中的“mMainThread.getApplicationThread()”：
   -  其中mMainThread就是我们的主线程ActivityThread，进程中的每个Activity对象都会持有它的引用。
   -  它的getApplicationThread方法返回的是一个IBinder对象。
-  你可能会疑惑，我们为何要注意这个参数呢？这是因为在startActivity这个操作中，会经历一系列方法调用，并且最终会跑到AMS的进程中去执行（因为启动Activity并不是简单的创建个对象就行的，它还涉及到很多事物要处理，但遵循“单一职责”的原则每个类都只管一件事，所以只能跳来跳去）。
   -  但是无论如何，实例化Activity对象的任务最终还是由我们的进程完成的，这一些列的方法调用只是为了通知系统各个地方，我们要启动Activity了，最终执行启动还是我们自己。
   -  就像刚才说的，在这个过程中程序会跨进程进入到AMS中执行，那么“有去就得有回”才行。
   -  所以，这个IBinder对象就是我们抛给AMS的一个IPC回调接口。
   -  当AMS处理完毕所有的事情后，就通过这个IBinder对象来给我们发通知，我们去执行后续操作。
</code></pre><h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p>　　上面的代码提到了<code>Instrumentation</code>，在<code>Framework</code>层混的好汉们，谁人不知道这个类？因此必须得介绍一下它。</p>
<pre><code>-  Instrumentation翻译为仪器、仪表，用于在应用程序中进行“测量”和“管理”工作。
-  Instrumentation将在进程启动的最开始时执行初始化（稍后详述），可以通过它监测Activity里的所有交互。
</code></pre><p>　　总之它有很多用途，而这里我们只介绍它与Activity相关的功能：</p>
<pre><code>-  一个Activity的创建、暂停、恢复操作，最终都会调用Instrumentation的方法来实现，如：
   -  创建时，会调用callActivityOnCreate 
   -  暂停时，会调用callActivityOnPause
   -  恢复时，会调用callActivityOnResume
-  而且一个进程中只有一个Instrumentation实例对象，就保存在ActivityThread中，且每个Activity都持有此对象的引用。
</code></pre><p><br>　　接着来看一下<code>Instrumentation</code>的<code>execStartActivity</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时将IBinder类型转换为IApplicationThread类型的了。</span></span><br><span class="line">    <span class="comment">// 其实这个IBinder对象就是ActivityThread的内部类ApplicationThread的对象。</span></span><br><span class="line">    <span class="comment">// 而该类就实现了IApplicationThread接口，所以可以顺利转换。</span></span><br><span class="line">    <span class="comment">// 看不懂这段描述也没关系，我稍后会详细介绍ApplicationThread。</span></span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用ActivityManagerNative去执行启动Activity，并将其返回值保存到result中。</span></span><br><span class="line">    <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">        .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测result的值。</span></span><br><span class="line">    checkStartActivityResult(result, intent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkStartActivityResult</span><span class="params">(<span class="keyword">int</span> res, Object intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果启动成功，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (res &gt;= ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="comment">// 如果无法从Intent中解析出要启动的Activity，或者找不到该Activity，则就报错。</span></span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_INTENT_NOT_RESOLVED:</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">            <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                        <span class="string">"Unable to find explicit activity class "</span></span><br><span class="line">                        + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                        + <span class="string">"; have you declared this activity in your AndroidManifest.xml?"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                    <span class="string">"No Activity found to handle "</span> + intent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在checkStartActivityResult方法中我们看见了这个久违的异常。
</code></pre><h2 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a>ActivityManager</h2><p>　　接下来的内容会涉及到<code>Binder</code>相关的知识，请先去阅读<a href="http://cutler.github.io/android-BY-C02/" target="_blank" rel="noopener">《Framework篇　第二章 Binder机制》</a>再继续往下阅读。</p>
<p><br>　　先来看一下<code>ActivityManagerNative.java</code>的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityManagerNative是一个抽象类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerNative</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerProxy</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  通过上一章的学习，我们可以得到如下对应关系：
   -  IActivityManager与IDAO对应。
   -  ActivityManagerNative与IDAO.Stub对应。
   -  ActivityManagerProxy与IDAO.Stub.Proxy对应。
-  另外，在IActivityManager里面定义各种操作三大组件（不包括内容提供者）的方法，同时AMS、AMN、AMP都实现这个接口。
</code></pre><p><br>　　接着上文，此时程序调用<code>ActivityManagerNative.getDefault</code>获取单例对象，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Singleton类用来定义一个单例对象。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从SM中查询出AMS的IBinder对象。</span></span><br><span class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用IBinder对象创建一个IActivityManager的实现类</span></span><br><span class="line">        IActivityManager am = asInterface(b);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Binder机制中，若client和server在同一进程中，那么Binder驱动会将server端的Binder对象直接传给client。</span></span><br><span class="line">    <span class="comment">// 但如果二者不在同一个进程中，那么Binder驱动就会为server端的Binder对象创建一个影子对象。</span></span><br><span class="line">    <span class="comment">// 这个影子对象就是BinderProxy类型的。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码通过调用IBinder接口的queryLocalInterface方法，尝试获取IActivityManager对象。</span></span><br><span class="line">    <span class="comment">// 如果obj对象是BinderProxy类型的话，in的值将为null。</span></span><br><span class="line">    IActivityManager in =</span><br><span class="line">        (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也就是说，如果obj对象是BinderProxy类型的话，就会使用obj去创建一个代理对象。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  很显然，由于AMS是在SystemServer进程中的，所以最终获得到的对象是ActivityManagerProxy类型的。
-  这意味着“ActivityManagerNative.getDefault().startActivity”调用的将是ActivityManagerProxy的方法。
</code></pre><p><br>　　然后，来看看调用<code>ActivityManagerProxy.startActivity</code>方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意第一个参数的类型变成了IApplicationThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步，把参数放到Parcel中，准备发给远程进程。</span></span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    <span class="comment">// 将我们的Binder对象传递给AMS，当AMS处理完一切后，就使用它通知我们。</span></span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，调用mRemote的transact方法，将参数传递到AMS进程中，并获取其返回值。</span></span><br><span class="line">    <span class="comment">// 其中ActivityManagerProxy类的mRemote属性是由刚才说的那个asInterface方法传递过来的。</span></span><br><span class="line">    <span class="comment">// 也就是说，最终将会调用BinderProxy的transact，执行跨进程通信的操作。</span></span><br><span class="line">    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步，将返回值返回，并回收Parcel所占用的资源。</span></span><br><span class="line">    <span class="keyword">int</span> result = reply.readInt();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在上一章中我们看过了类似的代码，这里不再重复解释。
</code></pre><p><br>　　然后又经历了下面一番调用：</p>
<pre><code>-  首先，经过Binder驱动的中转，在client端对BinderProxy.transact方法的调用会转给AMS的transact方法。
-  然后，由于AMS并没有重写transact方法，所以调用了它的父类ActivityManagerNative的transact方法。
-  但是，由于ActivityManagerNative也没有重写，所以最终调用了Binder类的transact方法。
</code></pre><p><br>　　那我们来看看<code>Binder</code>类的<code>transact</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"Binder"</span>, <span class="string">"Transact: "</span> + code + <span class="string">" to "</span> + <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        data.setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> r = onTransact(code, data, reply, flags);</span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  显而易见，程序会调用onTransact方法。
-  这次AMS重写了这个方法，它做了一些操作后，又调用了父类ActivityManagerNative的onTransact方法。
</code></pre><p><br>　　好吧，再去看看<code>ActivityManagerNative</code>的<code>onTransact</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将我们的Binder接口读取出来。</span></span><br><span class="line">        IBinder b = data.readStrongBinder();</span><br><span class="line">        IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">        String callingPackage = data.readString();</span><br><span class="line">        Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">        String resolvedType = data.readString();</span><br><span class="line">        IBinder resultTo = data.readStrongBinder();</span><br><span class="line">        String resultWho = data.readString();</span><br><span class="line">        <span class="keyword">int</span> requestCode = data.readInt();</span><br><span class="line">        <span class="keyword">int</span> startFlags = data.readInt();</span><br><span class="line">        ProfilerInfo profilerInfo = data.readInt() != <span class="number">0</span></span><br><span class="line">                ? ProfilerInfo.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">        Bundle options = data.readInt() != <span class="number">0</span></span><br><span class="line">                ? Bundle.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用当前对象的startActivity方法，并把我们的Binder对象传递过去。</span></span><br><span class="line">        <span class="keyword">int</span> result = startActivity(app, callingPackage, intent, resolvedType,</span><br><span class="line">                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  由于当前对象其实就是AMS，所以最终会调用AMS的startActivity方法。
</code></pre><p><br>　　然后在<code>AMS</code>的<code>startActivity</code>中又经历了如下调用：</p>
<pre><code>-  接着调用了ActivityManagerService的startActivityAsUser方法。
-  接着调用了ActivityStackSupervisor的startActivityMayWait方法。
-  接着调用了ActivityStackSupervisor的startActivityLocked方法。
-  接着调用了ActivityStackSupervisor的startActivityUncheckedLocked方法。
-  接着调用了ActivityStack的resumeTopActivityLocked方法。
-  接着调用了ActivityStack的resumeTopActivityInnerLocked方法。
-  接着调用了ActivityStackSupervisor的startSpecificActivityLocked方法。
-  接着调用了ActivityStackSupervisor的realStartActivityLocked方法。
</code></pre><p><br>　　我们来看一下<code>realStartActivityLocked</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">            System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">            <span class="keyword">new</span> Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">            task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">            newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  其中app.thread是类型的IApplicationThread，它就是我们从自己的进程中传递过来的回调。
-  从上面可以看出，当AMS处理完所有事情后，就会调用app.thread来将程序的执行流程交回给我们。
</code></pre><p><br>　　接下来打开<code>ApplicationThread</code>类的<code>scheduleLaunchActivity</code>方法，它又进行了如下调用：</p>
<pre><code>-  接着调用ActivityThread类的sendMessage方法，给ActivityThread的mH发送消息，消息的类型为H.LAUNCH_ACTIVITY。
-  接着调用ActivityThread类的handleLaunchActivity方法。
-  接着调用ActivityThread类的performLaunchActivity方法。
</code></pre><p><br>　　咱们来看看这个<code>performLaunchActivity</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先从ActivityClientRecord中获取待启动的Activity的组件信息。</span></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后调用Instrumentation类的newActivity方法，创建Activity类的对象。</span></span><br><span class="line">    java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">    activity = mInstrumentation.newActivity(</span><br><span class="line">            cl, component.getClassName(), r.intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接着调用了LoadedApk类的makeApplication方法创建Application对象（如果需要的话）。</span></span><br><span class="line">    Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接着调用Activity的attach方法，执行初始化操作。</span></span><br><span class="line">    <span class="comment">// 注意，此时ActivityThread会把自己的引用、自己的Instrumentation属性的引用传递给新Activity对象。</span></span><br><span class="line">    <span class="comment">// 这也就解释了，之前笔者说的整个进程中所有Activity共用一个Instrumentation对象的说法。</span></span><br><span class="line">    <span class="comment">// 同时也说明了，Activity的mMainThread属性就是指向的ActivityThread对象。</span></span><br><span class="line">    activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">            r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">            r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">            r.referrer, r.voiceInteractor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  注释写的很清楚了，也是不多说。
-  至于Activity的attach方法里面什么写什么代码，可以自己去看看。
</code></pre><p><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="http://www.kancloud.cn/digest/androidframeworks/127785" target="_blank" rel="noopener">Android Activity.startActivity流程简介</a></li>
</ul>
<h1 id="第四节-Service"><a href="#第四节-Service" class="headerlink" title="第四节 Service"></a>第四节 Service</h1><p>　　我们知道<code>Service</code>有两种启动方式，接下来就分别介绍它们的具体执行流程。</p>
<h2 id="普通启动"><a href="#普通启动" class="headerlink" title="普通启动"></a>普通启动</h2><p>　　当我们在<code>Activity</code>中调用<code>startService</code>方法时，程序执行的其实是<code>ContextWrapper</code>类的方法。</p>
<p><br>　　该方法的源码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.startService(service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　在继续向下讲解之前，需要先了解一下<code>Context</code>类的继承关系，如下图所示：</p>
<center><br><img src="/img/android/android_BY_c02_01.jpg" alt=""><br></center>

<p>　　图释：</p>
<pre><code>-  首先要知道的是，Context是一个抽象类没法实例化对象，所以我们开发时用到的Context对象都是它子类的对象。
-  然后从图上可以看出，Context有很多子类，其中比较常见的是ContextImpl和ContextWrapper。
   -  创建Activity时，需要传递给它一个Context对象，而这个对象就是ContextImpl类型的。
   -  而ContextWrapper之所以常见，就是因为它是Application、Service以及Activity的父类。
   -  提示：Activity的直接父类是ContextThemeWrapper。
</code></pre><p><br>　　既然上面说，<code>Activity</code>所持有的<code>Context</code>其实是<code>ContextImpl</code>类的对象，那么下面就用源码来证明：</p>
<pre><code>-  就像我们知道的那样，当启动Activity时，最终会调用ActivityThread的performLaunchActivity方法执行创建。在该方法中会依次做如下三件事：
   -  第一，创建Activity对象。
   -  第二，创建Application对象（如果需要的话）。
   -  第三，调用Activity的attach方法。
-  而事实上，在第二步和第三步之间，还有一步操作：创建Context对象。
   -  此时会调用ActivityThread的createBaseContextForActivity方法。
</code></pre><p><br>　　来看一下<code>createBaseContextForActivity</code>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">final</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            <span class="keyword">this</span>, r.packageInfo, displayId, r.overrideConfig);</span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line">    Context baseContext = appContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> baseContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从代码中可以看出来，实例化的就是ContextImpl类的对象。
</code></pre><p><br>　　我们接着来看一下<code>Activity</code>的<code>attach</code>方法的源码，看它是如何使用这个<code>ContextImpl</code>对象的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存Context的引用</span></span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Window对象，这个对象在研究Touch机制时会涉及到（Touch机制属于青铜选手的知识范围，已讲解）。</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存各类变量。</span></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化WindowManager对象，这个对象在研究Touch机制时会涉及到（Touch机制属于青铜选手的知识范围，已讲解）。</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  可以发现，Activity并没有简单的将Context保存到一个变量中，而是调用了attachBaseContext方法进行保存。
</code></pre><p><br>　　跟进去之后，就会发现最终会调用<code>ContextWrapper</code>类的<code>attachBaseContext</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mBase = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  至此我们就知道了，当我们在Activity中调用startService方法时，最终调用的是ContextImpl的方法。
</code></pre><p><br>　　然后把话题拉回来，接着从的<code>ContextImpl.startService</code>方法开始看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">        mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                    getContentResolver()), getOpPackageName(), user.getIdentifier());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从上面的代码可以知道，程序最终会执行到AMS所在的进程中，并调用AMS的startService方法。
</code></pre><p><br>　　然后在<code>AMS</code>的<code>startService</code>中又经历了如下调用：</p>
<pre><code>-  首先调用了ActiveServices的startServiceLocked方法。
   -  ActiveServices是一个辅助AMS进行Service管理的类，包括启动、绑定、停止服务等。
-  接着调用了ActiveServices的startServiceInnerLocked方法。
-  接着调用了ActiveServices的bringUpServiceLocked方法。
</code></pre><p><br>　　我们来看看<code>bringUpServiceLocked</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该服务已经被启动了，则调用它的生命周期方法（比如onStartCommand），然后直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行启动Service的工作</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用服务所在进程中的ActivityThread，通知它启动服务。</span></span><br><span class="line">    app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">            mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">            app.repProcState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接着调用服务的生命周期方法（比如onStartCommand）。</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  上面注释写的很清楚了，此后程序流程将回到服务所在的进程中。
</code></pre><p><br>　　与之前介绍的套路一样，最终会调用到<code>ActivityThread.handleCreateService</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化服务对象</span></span><br><span class="line">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Context对象。</span></span><br><span class="line">    ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">    context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Application对象。</span></span><br><span class="line">    Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用attach和onCreate方法。</span></span><br><span class="line">    service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">            ActivityManagerNative.getDefault());</span><br><span class="line">    service.onCreate();</span><br><span class="line">    <span class="comment">// 将服务对象保存起来。</span></span><br><span class="line">    mServices.put(data.token, service);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  对于服务的其它生命周期方法，最终也会调用到ActivityThread.handleServiceArgs方法，它的内容请自行去查看。
</code></pre><h2 id="绑定启动"><a href="#绑定启动" class="headerlink" title="绑定启动"></a>绑定启动</h2><p>　　绑定启动与普通启动的过程很相似。</p>
<p><br>　　经历了几次简单的调用，就调到了<code>ContextImpl.bindServiceCommon</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先获取一个IServiceConnection对象。</span></span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</span><br><span class="line">                mMainThread.getHandler(), flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后调用AMS的方法绑定服务，并将sd传递过去。</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在上面的代码中，涉及到一个IServiceConnection类的对象sd，简单的说它是对ServiceConnection的封装。
-  因为绑定服务是可能跨进程的，所以就要求客户端与服务之间的这个ServiceConnection对象得基于Binder机制。
-  如果跟进第10行代码的话，就会知道这个sd变量指向的对象本质上是ServiceDispatcher.InnerConnection类型的。并且它实现了IServiceConnection.Stub接口。
</code></pre><p><br>　　接着流程就走到了<code>AMS</code>的<code>bindService</code>方法，并在其中又经历了如下调用：</p>
<pre><code>-  接着调用了ActiveServices的bindServiceLocked方法。
-  接着调用了ActiveServices的bringUpServiceLocked方法。
-  接着调用了ActiveServices的realStartServiceLocked方法。
</code></pre><p>　　细心的读者可以发现，后两步和普通启动<code>Service</code>执行的流程是一样的，具体过程就不冗述了。</p>
<p><br>　　但是与普通启动方式不同的是，绑定启动服务在调用完服务的<code>onCreate</code>方法之后，还会接着调用<code>onBinder</code>方法。<br>　　我们来细化一下<code>realStartServiceLocked</code>方法的执行步骤：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用服务所在进程中的ActivityThread，通知它启动服务。</span></span><br><span class="line">    app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">            mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">            app.repProcState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试调用服务的onBinder方法。</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接着调用服务的生命周期方法（比如onStartCommand）。</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　为了锻炼大家的阅读源码的能力，就不带大家看源码了，只简单的说一下步骤：</p>
<pre><code>-  在requestServiceBindingsLocked中最终会调用服务所在进程的ActivityThread的scheduleBindService方法。
-  然后就是调用handleBindService方法。
</code></pre><p><br>　　来看一下<code>handleBindService</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, <span class="string">"handleBindService s="</span> + s + <span class="string">" rebind="</span> + data.rebind);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    <span class="comment">// 1、onBind方法只会在第一个访问者和服务建立连接时会调用。</span></span><br><span class="line">                    <span class="comment">// 2、onBind方法的返回值IBinder代表服务的一个通信管道，访问者通过该对象来访问服务中的方法。</span></span><br><span class="line">                    <span class="comment">// 3、onBind方法返回的IBinder对象会被传送给ServiceConnection接口的onServiceConnected方法。</span></span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    <span class="comment">// 将服务的IBinder对象传递给客户端进程。</span></span><br><span class="line">                    ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to bind to service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　接着流程就走到了<code>AMS</code>的<code>publishService</code>方法，并调用了<code>ActiveServices</code>的<code>publishServiceLocked</code>方法。</p>
<p><br>　　在<code>publishServiceLocked</code>方法中，有如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用客户端传递过来的LoadedApk.ServiceDispatcher.InnerConnection对象的connected方法。</span></span><br><span class="line">        c.conn.connected(r.name, service);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failure sending service "</span> + r.name +</span><br><span class="line">              <span class="string">" to connection "</span> + c.conn.asBinder() +</span><br><span class="line">              <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在InnerConnection的connected方法中，会转调用它外部类ServiceDispatcher的connected方法。
</code></pre><p><br>　　接着就来看一下<code>ServiceDispatcher.connected</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 向主线程中发送消息。</span></span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  其实如果你去追踪源码的话，就会发现mActivityThread其实就是主线程中的那个mH。
</code></pre><p><br>　　后面的代码就不带大家看了，只简单的说一下步骤：</p>
<pre><code>-  首先，主线程会调用RunConnection的run方法。
-  然后，会转调用doConnected方法。
-  最后，在doConnected方法中就可以看到onServiceConnected的调用了。
</code></pre><h1 id="第五节-BroadcastReceiver"><a href="#第五节-BroadcastReceiver" class="headerlink" title="第五节 BroadcastReceiver"></a>第五节 BroadcastReceiver</h1><p>　　广播接收者的工作过程，主要包含两方面：广播的注册、广播的发送和接收；本节来简单介绍一下这两个过程。</p>
<p><br><strong>动态注册</strong></p>
<p>　　广播的注册分为静态注册和动态注册，其中静态注册的广播是在应用安装时由系统自动完成注册，具体来说是由<code>PMS</code>来完成整个注册过程的。</p>
<pre><code>-  PMS就是PackageManagerService。
-  除了广播注册的过程外，其它三大组件只能在应用安装时由PMS解析并注册。
</code></pre><p><br>　　这里只分析广播的动态注册的过程，最先调用的同样是<code>ContextWrapper</code>类的<code>registerReceiver</code>方法。</p>
<p>　　经过几次跳转之后，程序就执行到了<code>ContextImpl</code>类的<code>registerReceiverInternal</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        IntentFilter filter, String broadcastPermission,</span></span></span><br><span class="line"><span class="function"><span class="params">        Handler scheduler, Context context)</span> </span>&#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, filter, broadcastPermission, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从上面的代码可以发现，广播的注册和服务的绑定的步骤很类似，这是因为它们本质上都是在进行IPC。
-  在上面的代码中，涉及到一个IIntentReceiver类的对象rd，简单的说它是对BroadcastReceiver的封装。
-  如果跟进第10行代码的话，就会知道这个rd变量指向的对象本质上是ReceiverDispatcher.InnerReceiver类型的。并且它实现了IIntentReceiver.Stub接口。
</code></pre><p><br>　　接着流程就走到了<code>AMS</code>的<code>registerReceiver</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Binder对象保存起来，当广播来临时用它进行回调。</span></span><br><span class="line">    mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个意图过滤器，用来让系统匹配广播。</span></span><br><span class="line">    BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">            permission, callingUid, userId);</span><br><span class="line">    rl.add(bf);</span><br><span class="line">    <span class="keyword">if</span> (!bf.debugCheck()) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"==&gt; For Dynamic broadcast"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将意图过滤器保存起来。</span></span><br><span class="line">    mReceiverResolver.addFilter(bf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  正如大家看到的那样，所谓的广播注册，本质上就是在AMS中添加一些记录。
</code></pre><p><br><strong>发送广播</strong></p>
<p>　　当我们通过<code>sendXxx</code>方法发送广播时，<code>AMS</code>会查找出匹配的广播接收者并将广播发送给它们处理。</p>
<pre><code>-  广播有普通广播和有序广播之分。
-  虽然二者有不同的特性，但是它们发送和接收的过程是类似的，因此这里只分析普通广播的实现。
</code></pre><p><br>　　我们依然是从<code>ContextImpl</code>类的<code>sendBroadcast</code>方法开始说，然后会调用<code>AMS</code>的<code>broadcastIntent</code>方法。</p>
<p>　　然后会接着调用<code>AMS</code>的<code>broadcastIntentLocked</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span></span><br><span class="line"><span class="function"><span class="params">            String callerPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">            IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle resultExtras, String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle options,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    intent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Android 3.1开始的Android加入了一种保护机制，这个机制导致程序接收不到某些系统广播，其中就包含了开机启动广播。</span></span><br><span class="line">    <span class="comment">// 系统为Intent添加了两个flag，FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES。</span></span><br><span class="line">    <span class="comment">// 用来控制Intent是否要对处于stopped状态的App起作用，如果一个App安装后未启动过或者被用户在管理应用中手动</span></span><br><span class="line">    <span class="comment">// 停止（强行停止）的话，那么该App就处于stopped状态了。</span></span><br><span class="line">    <span class="comment">// FLAG_INCLUDE_STOPPED_PACKAGES：表示包含stopped的App</span></span><br><span class="line">    <span class="comment">// FLAG_EXCLUDE_STOPPED_PACKAGES：表示不包含stopped的App</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Android3.1开始，系统会为所有广播默认添加FLAG_EXCLUDE_STOPPED_PACKAGES标识。</span></span><br><span class="line">    <span class="comment">// 当FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES共存时，以前者为准。</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((receivers != <span class="keyword">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">            || resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing ordered broadcast "</span> + r</span><br><span class="line">                + <span class="string">": prev had "</span> + queue.mOrderedBroadcasts.size());</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Enqueueing broadcast "</span> + r.intent.getAction());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            <span class="comment">// 将所有满足条件的广播接收者放到BroadcastQueue中。</span></span><br><span class="line">            queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">            <span class="comment">// 发送广播。</span></span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>语句解释：
-  无。
</code></pre><p><br>　　接着流程就走到了<code>BroadcastQueue</code>的<code>scheduleBroadcastsLocked</code>方法，并在其中又经历了如下调用：</p>
<pre><code>-  接着在其内部通过Handler发送一个消息。
-  接着调用了BroadcastQueue的processNextBroadcast方法。
-  接着调用了BroadcastQueue的deliverToRegisteredReceiverLocked方法。
-  接着调用了BroadcastQueue的performReceiveLocked方法。
</code></pre><p><br>　　我们来看看<code>performReceiveLocked</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performReceiveLocked</span><span class="params">(ProcessRecord app, IIntentReceiver receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">// Send the intent to the receiver asynchronously using one-way binder calls.</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we have an app thread, do the call through that so it is</span></span><br><span class="line">            <span class="comment">// correctly ordered with other one-way calls.</span></span><br><span class="line">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Application has died. Receiver doesn't exist.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException(<span class="string">"app.thread must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  显而易见，此时程序的流程会回到广播接收者所在的进程中的ApplicationThread类。
</code></pre><p><br>　　那接着就来看看<code>ApplicationThread.scheduleRegisteredReceiver</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用之前创建的ReceiverDispatcher.InnerReceiver对象的方法。</span></span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  接着在ReceiverDispatcher.InnerReceiver中又会调用在ReceiverDispatcher的performReceive方法。
-  接着会创建一个Args对象，并把它放到主线程中执行，Args是Runnable的子类。
-  接着在Args类的run方法里就可以看到对广播接收者onReceive的调用。
</code></pre><h1 id="第六节-ContentProvider"><a href="#第六节-ContentProvider" class="headerlink" title="第六节 ContentProvider"></a>第六节 ContentProvider</h1><p>　　内容提供者也是通过<code>Binder</code>机制向其他组件提供数据的：</p>
<pre><code>-  当ContentProvider所在的进程被启动时，ContentProvider会同时启动并被发布到AMS中。
-  另外，ContentProvider的onCreate方法比Application的onCreate方法更早被调用。
-  这意味着，如果我们想知道ContentProvider的启动过程的话，那就势必得得看进程启动相关的代码了。
</code></pre><p><br>　　在第一节中我们分析了进程的启动流程的前半部分，接下来就接着一起来看看后半部分。</p>
<p>　　那咱们就从<code>ActivityThread</code>的<code>attach</code>方法开始：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mgr.attachApplication(mAppThread);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在attach方法中会进行一系列的初始化操作。
-  其中比较重要的一步就是，会将ActivityThread通过AMS的attachApplication方法跨进程传递到AMS中。
</code></pre><p><br>　　在<code>AMS</code>的<code>attachApplication</code>方法中又调用了<code>attachApplicationLocked</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用用户进程的bindApplication方法，通知其注册完毕。</span></span><br><span class="line">    thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">            profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">            app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,</span><br><span class="line">            isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">            <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">            getCommonServicesLocked(app.isolated),</span><br><span class="line">            mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们来缕一下流程：</span></span><br><span class="line">    <span class="comment">// 首先，当我面启动一个Activity时，系统会判断：</span></span><br><span class="line">    <span class="comment">//      若该Activity所在的进程已经存在，则直接启动，并返回。</span></span><br><span class="line">    <span class="comment">//      若该Activity所在的进程不存在，则AMS会先去开启一个进程。</span></span><br><span class="line">    <span class="comment">// 接着，当新进程启动完毕后，新进程会按照上面说的那样，调用AMS的方法把它自己的ActivityThread注册到AMS中。</span></span><br><span class="line">    <span class="comment">// 接着，当AMS给新进程发送“注册完毕”的通知后，它就会检测：</span></span><br><span class="line">    <span class="comment">//      是否有需要启动的Activity、Service、BroadcastReceiver? 如果有，则就启动它们。</span></span><br><span class="line">    <span class="comment">//      而下面的这个代码，就是检测是否需要启动Activity的，相应的还有启动服务和广播接收者的代码，</span></span><br><span class="line">    <span class="comment">//      不过被我给省略了。之所以没有ContentProvider，是因为他是在进程启动的时候，就同时被启动了。</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown launching activities in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码，其中就包括对Service、BroadcastReceiver的启动相关的代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  各位可以去mStackSupervisor.attachApplicationLocked中看看，是否有启动Activity相关的代码。
</code></pre><p><br>　　当程序流程回到用户进程的时候，会在主线程中调用<code>handleBindApplication</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一，创建Instrumentation对象。</span></span><br><span class="line">    java.lang.ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">    mInstrumentation = (Instrumentation)</span><br><span class="line">        cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二，创建Application对象。</span></span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">    mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三，启动当前进程的ContentProvider并调用onCreate方法</span></span><br><span class="line">    <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">        List&lt;ProviderInfo&gt; providers = data.providers;</span><br><span class="line">        <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            installContentProviders(app, providers);</span><br><span class="line">            <span class="comment">// For process that contains content providers, we want to</span></span><br><span class="line">            <span class="comment">// ensure that the JIT is enabled "at some point".</span></span><br><span class="line">            mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四，调用Application对象的onCreate方法。</span></span><br><span class="line">        </span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  在handleBindApplication方法中做了很多事，我们主要就关注上面四件事。
-  就像第二节说的那样，整个进程中只会有一个对象Instrumentation，而这个对象就是在此时创建的。
</code></pre><p><br>　　接着深入<code>installContentProviders</code>方法去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有内容提供者</span></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">            buf.append(<span class="string">"Pub "</span>);</span><br><span class="line">            buf.append(cpi.authority);</span><br><span class="line">            buf.append(<span class="string">": "</span>);</span><br><span class="line">            buf.append(cpi.name);</span><br><span class="line">            Log.i(TAG, buf.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在下面的installProvider方法中执行了实例化ContentProvider的操作。</span></span><br><span class="line">        <span class="comment">// 然后通过ContentProvider的attachInfo方法来调用其onCreate方法。</span></span><br><span class="line">        <span class="comment">// 接着将ContentProvider封装成一个cph对象，并把它放入到results中。</span></span><br><span class="line">        IActivityManager.ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将这些内容提供者发布到AMS中。</span></span><br><span class="line">        ActivityManagerNative.getDefault().publishContentProviders(</span><br><span class="line">            getApplicationThread(), results);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  和服务、广播接收者一样，做为组件是不能直接跨进程的，所以要将他封装成一个ContentProviderHolder对象。
-  在AMS的publishContentProviders方法中，会将这些观察者保存到一个名为mProviderMap的属性里。
</code></pre><p><br>　　接着深入<code>installProvider</code>方法去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IActivityManager.<span class="function">ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">    IActivityManager.ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">    localProvider = (ContentProvider)cl.</span><br><span class="line">        loadClass(info.name).newInstance();</span><br><span class="line">    <span class="comment">// 获取ContentProvider的IContentProvider对象。</span></span><br><span class="line">    provider = localProvider.getIContentProvider();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line"></span><br><span class="line">    localProvider.attachInfo(c, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  之所以要将ContentProviderHolder传给AMS，是为了当AMS接到请求时，好把请求转给内容提供者处理。
-  因此这是一个跨进程的操作，也就是说ContentProviderHolder内部都应该是支持跨进程的。
-  但是做为组件的ContentProvider是不能跨进程的。
-  所以被封装到ContentProviderHolder中的其实是IContentProvider对象，它是一个Binder接口。
-  可以进入到内容提供者的getIContentProvider方法里看看，它返回的是一个Transport对象。
-  当AMS转发的请求最后就会交给这个Transport处理。
</code></pre><p><br>　　现在我们回过头来看看，当客户端访问<code>ContentProvider</code>的<code>query</code>方法时，程序的执行流程。</p>
<pre><code>-  首先调用的依然是ContextWrapper类的getContentResolver方法。
-  接着通过追踪源码可以发现，会转调用ApplicationContentResolver的query方法。
-  接着由于ApplicationContentResolver没有重写query方法，所以会调用ContentResolver的。
-  接着会调用acquireUnstableProvider方法。
-  接着经历一些跳转，会调用到ActivityThread的acquireProvider方法。
-  接着会调用AMS的getContentProvider方法，然后进行一些列的调用，最终返回一个IContentProvider对象。
-  接着再用这个IContentProvider对象调用query方法，也就是调用到Transport对象中了。
</code></pre><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>　　至此，本章就算完结了，以后有时间再来进一步完善细节部分。</p>
<p>　　如果想看<code>C/C++</code>部分的源码分析，则等笔者晋级到<code>“黄金分段”</code>时再说吧。</p>
<p><br><br></p>

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
        </div>
      

      
      
    </footer>
  </article>


  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="android-framework-003/"
           data-title="Framework篇 第三章 系统、进程、四大组件启动过程" data-url="http://yoursite.com/android-framework-003/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="乐信圣文" />
          <p class="site-author-name" itemprop="name">乐信圣文</p>
          <p class="site-description motion-element" itemprop="description">集大家之成，悟小家之道。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">48</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="http://www.gov.cn/" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一节-系统的启动"><span class="nav-number">1.</span> <span class="nav-text">第一节 系统的启动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础入门"><span class="nav-number">1.1.</span> <span class="nav-text">基础入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zygote进程"><span class="nav-number">1.2.</span> <span class="nav-text">Zygote进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二节-进程的启动"><span class="nav-number">2.</span> <span class="nav-text">第二节 进程的启动</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三节-Activity的启动"><span class="nav-number">3.</span> <span class="nav-text">第三节 Activity的启动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Instrumentation"><span class="nav-number">3.1.</span> <span class="nav-text">Instrumentation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ActivityManager"><span class="nav-number">3.2.</span> <span class="nav-text">ActivityManager</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四节-Service"><span class="nav-number">4.</span> <span class="nav-text">第四节 Service</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#普通启动"><span class="nav-number">4.1.</span> <span class="nav-text">普通启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定启动"><span class="nav-number">4.2.</span> <span class="nav-text">绑定启动</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五节-BroadcastReceiver"><span class="nav-number">5.</span> <span class="nav-text">第五节 BroadcastReceiver</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六节-ContentProvider"><span class="nav-number">6.</span> <span class="nav-text">第六节 ContentProvider</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结尾"><span class="nav-number">7.</span> <span class="nav-text">结尾</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乐信圣文</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cutler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("sGcgYofeKOFi2l1XvGrm0PcP-gzGzoHsz", "Sx0mWxj4pkXYm17zT0UnV5Ca");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
