<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="http://www.gov.cn/" title="乐信圣文" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Android系统内置了许多控件，如果这些控件不能满足需求，您可以自定义自己的控件，自定义的控件必须继承View类。 三种自定义控件的方式　　按实现方式来划分的话，自定义View分为三种：自绘控件、组合控件、以及继承控件。 -  自绘控件：View上所展现的内容全部都是我们自己绘制出来的。此种方式也是最难的，一般会通过直接继承View类来实现自定义控件。 -  继承控件：如果对已有的控件进行小">
<meta property="og:type" content="article">
<meta property="og:title" content="自定义控件篇　第一章 基础入门">
<meta property="og:url" content="http://yoursite.com/android-G01/index.html">
<meta property="og:site_name" content="乐信圣文">
<meta property="og:description" content="Android系统内置了许多控件，如果这些控件不能满足需求，您可以自定义自己的控件，自定义的控件必须继承View类。 三种自定义控件的方式　　按实现方式来划分的话，自定义View分为三种：自绘控件、组合控件、以及继承控件。 -  自绘控件：View上所展现的内容全部都是我们自己绘制出来的。此种方式也是最难的，一般会通过直接继承View类来实现自定义控件。 -  继承控件：如果对已有的控件进行小">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/android/android_f05_01.png">
<meta property="og:image" content="http://yoursite.com/img/android/android_f05_02.png">
<meta property="og:image" content="http://yoursite.com/img/android/android_b09_01.png">
<meta property="og:image" content="http://img.blog.csdn.net/20150602150418233?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzI4NTU0MTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://yoursite.com/img/android/android_b08_05.png">
<meta property="og:image" content="http://img.blog.csdn.net/20131223234856718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2018-09-09T10:47:48.470Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="自定义控件篇　第一章 基础入门">
<meta name="twitter:description" content="Android系统内置了许多控件，如果这些控件不能满足需求，您可以自定义自己的控件，自定义的控件必须继承View类。 三种自定义控件的方式　　按实现方式来划分的话，自定义View分为三种：自绘控件、组合控件、以及继承控件。 -  自绘控件：View上所展现的内容全部都是我们自己绘制出来的。此种方式也是最难的，一般会通过直接继承View类来实现自定义控件。 -  继承控件：如果对已有的控件进行小">
<meta name="twitter:image" content="http://yoursite.com/img/android/android_f05_01.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/android-G01/"/>

  <title> 自定义控件篇　第一章 基础入门 | 乐信圣文 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?53b4b0b5aeb5df5e4fb6263a58d8e1a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">乐信圣文</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feedback">
          <a href="/feedback" rel="section">
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                自定义控件篇　第一章 基础入门
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-29T11:41:12+08:00" content="2015-04-29">
              2015-04-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android开发-倔强青铜/" itemprop="url" rel="index">
                    <span itemprop="name">Android开发 - 倔强青铜</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/android-G01/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="android-G01/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/android-G01/" class="leancloud_visitors" data-flag-title="自定义控件篇　第一章 基础入门">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>　　<code>Android</code>系统内置了许多控件，如果这些控件不能满足需求，您可以自定义自己的控件，自定义的控件必须继承<code>View</code>类。</p>
<p><br><strong>三种自定义控件的方式</strong><br><br>　　按实现方式来划分的话，自定义View分为三种：自绘控件、组合控件、以及继承控件。</p>
<pre><code>-  自绘控件：View上所展现的内容全部都是我们自己绘制出来的。此种方式也是最难的，一般会通过直接继承View类来实现自定义控件。
-  继承控件：如果对已有的控件进行小调整就能满足需求，那么可以通过继承它们并重写onDraw()方法来实现自定义控件。比如，继承EditText使之产生了带有下划线的记事本页面。
-  组合控件：通过将几个系统原生的控件组合到一起，来实现自定义控件。比如，使用PopupWindow和Button来组合出一个下拉列表框等。
</code></pre><p><br>　　为了更好的理解自定义控件的各个步骤，在正式开始之前，我们先来了解一些相关的知识点：Activity的组成。</p>
<h1 id="第一节-Activity的组成"><a href="#第一节-Activity的组成" class="headerlink" title="第一节 Activity的组成"></a>第一节 Activity的组成</h1><p>　　本节来介绍一下<code>Window</code>、<code>WindowManagerService</code>、<code>WindowManager</code>三个类。</p>
<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>　　我们都知道，在Android中，屏幕上所显示的控件是以Activity为单位进行组织的。<br>　　但是再深入点看的话，就会发现Activity其实主要是处理一些逻辑问题（比如生命周期的管理等），显示在屏幕上的控件并不是由它来管理的，而是交给了<code>Window</code>类。</p>
<p>　　不信的话，可以打开Activity类的源码，看一下它的setContentView方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Window mWindow;</span><br><span class="line"><span class="keyword">private</span> WindowManager mWindowManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从上面可以发现，Activity会转调用Window类的setContentView方法。
-  再次声明，Android系统的源码每个版本之间都会有一些差别，所以笔者在本章以及以后章节中所贴出的源码，如果和你看到的源码不一致，那么请淡定！
   -  笔者使用的源码版本是：Android-23 。
</code></pre><p><br>　　观察仔细点的话会发现Window是一个抽象类，为了能继续追踪源码，我们得先去查看<code>mWindow</code>是何时初始化的，进而找到实例化的是哪个类。<br>　　查看的过程以后再说，直接说结果吧：</p>
<pre><code>-  首先，当我们请求启动某个Activity时，系统会调用它的无参构造方法实例化一个它的对象。
-  然后，会调用该对象的attach方法，执行初始化操作，而它的mWindow属性就是在attach方法中初始化的。
</code></pre><p><br>　　那么就来看一下Activity的<code>attach</code>方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="comment">/*此处省略若干参数*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据一些参数，来初始化WindowManager对象。</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为mWindowManager属性赋值。</span></span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  其实Window类官方文档已经告诉我们了，该类只有一个唯一的子类android.view.PhoneWindow。
-  如果继续追踪上面第8行代码的话，还可以知道mWindowManager所指向的对象将是WindowManagerImpl类型的。
-  用一句话概括：“当Activity被实例化之后，会接着初始化它的mWindow、mWindowManager属性”。
</code></pre><p><br>　　继续追踪就会发现，我们调用<code>setContentView</code>方法设置给Activity的布局，最终会由<code>PhoneWindow</code>类的<code>DecorView</code>管理。</p>
<p>　　这里先给出一个完整的示意图，后面会详细分析：</p>
<center><br><img src="/img/android/android_f05_01.png" alt="Activity内部结构"><br></center>

<p>　　<code>DecorView</code>是<code>PhoneWindow</code>的内部类，继承自<code>FrameLayout</code>。还有一点需要知道的是：</p>
<pre><code>-  笔者之所以说Activity的控件是由DecorView管理的，而不说是由PhoneWindow管理的，是因为：
   -  DecorView是一个真正的View对象，我们设置给Activity的布局，最终会被放到DecorView里面。
   -  而PhoneWindow并不是一个View。
</code></pre><p><br>　　回到刚才说的地方，我们来看一下<code>PhoneWindow</code>类的<code>setContentView</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mContentParent就是上图的R.id.content所对应的布局。</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mContentParent没有值就意味着DecorView没被初始化，下面就去初始化。</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="comment">// 如果已经初始化了，则删除现有的所有子View。</span></span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将用户传递过来的布局，放入到mContentParent中。</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  这段代码用来检测DecorView是否初始化完毕，然后再将layoutResID所对应的布局放到DecorView中。
</code></pre><p><br>　　接着看一下<code>installDecor</code>、<code>generateDecor</code>、<code>generateLayout</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建DecorView。</span></span><br><span class="line">        mDecor = generateDecor();</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取R.id.content所对应的布局，并把它赋值给mContentParent。</span></span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据当前设备的情况来决定使用哪个布局。</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_LEFT_ICON) | (<span class="number">1</span> &lt;&lt; FEATURE_RIGHT_ICON))) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; ((<span class="number">1</span> &lt;&lt; FEATURE_PROGRESS) | (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; (features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_CUSTOM_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装载布局，并将它放入到DecorView中。</span></span><br><span class="line">    View in = mLayoutInflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    decor.addView(in, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    <span class="comment">// 这个mContentRoot在上面的图中有标注。</span></span><br><span class="line">    mContentRoot = (ViewGroup) in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从DecorView中查找出id为R.id.content的布局。</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDecorView().findViewById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  至此也就看明白了，传递给setContentView方法的布局，最终会被放入到DecorView中。
-  第23行代码用来获取当前窗口配置，后面会依据该方法的返回值来决定使用哪个布局。
   -  例如，窗口配置类型包括FullScreen(全屏)、NoTitleBar(不含标题栏)等。
</code></pre><p><br>　　另外，我们可以使用Activity的<code>requestFeature()</code>方法来修改窗口配置，不过该方法必须在<code>setContentView</code>之前调用。<br>　　从<code>PhoneWindow</code>类的<code>requestFeature</code>方法可以看出，若在<code>setContentView</code>之后修改窗口配置，会抛异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestFeature</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"requestFeature() must be called before adding content"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.requestFeature(featureId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　默认情况下，<code>DecorView</code>内部只有一个子元素，也就是上面说的<code>mContentRoot</code>，而且<code>mContentRoot</code>一般是<code>LinearLayout</code>的子类，里面包含<code>标题栏</code>和<code>内容区域</code>两部分：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--   android-sdk\platforms\android-8\data\res\layout\screen.xml   --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Title bar and content --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span>  <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Title bar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">android:id</span>=<span class="string">"@android:id/title_container"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"?android:attr/windowTitleBackgroundStyle"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"?android:attr/windowTitleSize"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 此处省略若干行代码 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Content --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:foregroundGravity</span>=<span class="string">"fill_horizontal|top"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:foreground</span>=<span class="string">"?android:attr/windowContentOverlay"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  我们调用Activity的setContentView()方法设置的布局，最终会以子结点的形式加入到这个FrameLayout中。
</code></pre><p><br>　　比如，我们可以在<code>Activity</code>中通过代码来控制<code>内容区域</code>的显示与隐藏。<br>　　范例1：隐藏<code>contentView</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FrameLayout的id为android.R.id.content。</span></span><br><span class="line">        findViewById(android.R.id.content).setVisibility(View.GONE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  您可以直接输出findViewById(android.R.id.content)的值来验证是否是一个帧布局。
-  你也可以在onCreate方法中隐藏掉标题栏、状态栏，具体的代码请自行搜索。
</code></pre><h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><p>　　通过上面的分析，我们知道DecorView是何时创建的了，但它是如何被添加到屏幕上的呢？</p>
<pre><code>答案是：通过WindowManagerService类来完成的。
</code></pre><p><br>　　下面给出一张示意图：</p>
<center><br><img src="/img/android/android_f05_02.png" alt="Activity深层结构图"><br></center>

<p>　　我们从下往上看这张图，整个图分为三部分：</p>
<pre><code>-  SdkClient部分表示Activity的内部结构，由PhoneWindow和DecorView组成。
-  FrameworkServer端用来完成整个Android系统的窗口、事件捕获和分发、输入法等的控制。
-  FrameworkClient用来连接SdkClient端和FrameworkServer端，它通过Binder机制让两者跨进程通信。
-  从上图可以看出，WindowManagerService（简称WMS）只会和ViewRoot类通信，DecorView则是通过WindowManager类来与ViewRoot通信。
</code></pre><p><br><strong>添加Activity到屏幕</strong></p>
<p>　　比如我们现在新建一个Activity，那么此时系统会这么执行：</p>
<pre><code>-  第一，先实例化Activity对象，然后调用attach方法、setContentView方法初始化。
-  第二，当需要显示Activity时，系统会使用WindowManager类来将DecorView添加到屏幕上。
-  第三，但WindowManager并不会执行添加操作，它会为DecorView创建一个ViewRoot对象，然后再请ViewRoot去添加。
-  第四，但ViewRoot实际上也不会执行添加操作，它会使用Binder机制（跨进程）访问远程的WMS类，也就是说添加操作会由WMS来完成。
</code></pre><p>　　上面只是说了一下大体执行步骤，下面就来跟随源码一起，观察一个新Activity被添加到屏幕中的过程。</p>
<p><br>　　第一步，当系统准备resume一个Activity时，会调用<code>ActivityThread</code>的<code>handleResumeActivity</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">            wm.addView(decor, l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">    <span class="comment">// we started another activity, then don't yet make the</span></span><br><span class="line">    <span class="comment">// window visible.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">            TAG, <span class="string">"Launch "</span> + r + <span class="string">" mStartedActivity set"</span>);</span><br><span class="line">        r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从第17行代码可以看出来，系统会调用WindowManager的addView方法来将DecorView添加到屏幕上。
-  通过前面的分析可以知道，实际上调用的是WindowManagerImpl类的addView方法。
-  继续跟进的话，就会看到最终会调用WindowManagerGlobal的addView方法。
</code></pre><p><br>　　第二步，查看<code>WindowManagerGlobal</code>类的<code>addView</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  此方法里创建一个ViewRootImpl对象，这个对象很重要：
   -  当WMS需要分发事件、绘制控件时都会通知ViewRootImpl，然后再由ViewRootImpl来通知DecorView。
   -  相应的，当想往屏幕上添加控件时，也得通过ViewRootImpl类来将控件传递给WMS。
-  第15行代码调用了ViewRootImpl的setView方法，同时将DecorView传递过去。
</code></pre><p><br>　　第三步，查看<code>ViewRootImpl</code>类的<code>setView</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  持有DecorView的引用。</span></span><br><span class="line">    mView = view;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用WindowManagerService来执行添加操作。</span></span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">            mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  此方法第4行代码，首先保存了DecorView的引用，因为以后会用到它。
-  可以把WindowSession类理解为WMS抛给咱们进程的回调，第9行代码调用addToDisplay方法来请求WMS执行一些初始化操作。当然此时屏幕上还没有绘制任何内容，不过我们就不继续向下深入了，只需要知道控件的绘制等操作是在WMS那端完成的即可。
</code></pre><p><br><strong>分发输入事件</strong></p>
<p>　　除了负责往屏幕上添加和删除控件外，WMS还会用来分发输入事件。</p>
<p>　　以触摸事件为例：</p>
<pre><code>触摸事件是由Linux内核的一个Input子系统来管理的(InputManager)，Linux子系统会在/dev/input/这个路径下创建硬件输入设备节点(这里的硬件设备就是我们的触摸屏了)。当手指触动触摸屏时，硬件设备通过设备节点像内核(其实是InputManager管理)报告事件，InputManager经过处理将此事件传给Android系统的一个系统Service —— WindowManagerService 。
</code></pre><p><br>　　当WMS接收到一个输入事件时，会按照下面的路线传递：</p>
<pre><code>-  首先，把事件传递给当前前台Activity的ViewRootImpl类。
-  然后，ViewRootImpl又会将事件传递给它的内部类ViewPostImeInputStage，该类依据事件的类型来调用不同的方法：
   -  processPointerEvent方法：处理触屏事件。
   -  processTrackballEvent方法：处理轨迹球事件。
   -  processKeyEvent方法：处理键盘事件。
</code></pre><p>　　接着，同样以触屏事件为例，<code>processPointerEvent</code>方法在接到事件后，源代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">    mAttachInfo.mUnbufferedDispatchRequested = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将事件传递给DecorView的dispatchPointerEvent方法。</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = mView.dispatchPointerEvent(event);</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) &#123;</span><br><span class="line">        mUnbufferedInputDispatch = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mConsumeBatchedInputScheduled) &#123;</span><br><span class="line">            scheduleConsumeBatchedInputImmediately();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled ? FINISH_HANDLED : FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从第6行代码可以看到调用了DecorView的dispatchPointerEvent方法，该方法继承自View类。
</code></pre><p>　　接着来看一下View类的<code>dispatchPointerEvent</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前处于触摸模式，则调用View类的dispatchTouchEvent方法。</span></span><br><span class="line">    <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchGenericMotionEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  就像我们看到的那样，一般情况下，会接着转调用View类的dispatchTouchEvent方法。
</code></pre><p>　　接着，看一下<code>DecorView</code>的<code>dispatchTouchEvent</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">return</span> cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span> ? cb.dispatchTouchEvent(ev)</span><br><span class="line">            : <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  这里的Callback是一个关键点，实际上它就是DecorView所属的Activity。
-  在Activity的attach方法中可以找到初始化的代码：“mWindow.setCallback(this);”。
</code></pre><p><br>　　分析到此也就明白了，输入事件的传递顺序为：</p>
<pre><code>WMS -&gt; ViewRootImpl -&gt; DecorView -&gt; Activity 
</code></pre><p><br><strong>执行绘制操作</strong></p>
<p>　　与分发输入事件的过程类似，当系统需要绘制Activity的界面时，也会执行下面的步骤：</p>
<pre><code>-  首先，调用ViewRootImpl的performTraversals方法。
-  然后，该方法依据具体的情况来调用不同的子方法：
   -  performMeasure方法：执行测量操作。其内部会转调用DecorView的measure方法。
   -  performLayout方法：执行布局操作。其内部会转调用DecorView的layout方法。
   -  performDraw方法：执行绘制操作。其内部会转调用DecorView的draw方法。
</code></pre><p>　　其实<code>DecorView</code>类的<code>measure</code>、<code>layout</code>、<code>draw</code>三个方法都是继承自View类，而且我们稍后也会遇到它，所以此处先将它们列出来，混脸熟。</p>
<p><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="http://1025250620.iteye.com/blog/1779670" target="_blank" rel="noopener">Android 窗口管理</a></li>
<li><a href="http://www.ithao123.cn/content-2273147.html" target="_blank" rel="noopener">Android Touch事件的分发过程</a></li>
<li><a href="http://stackvoid.com/details-dispatch-onTouch-Event-in-Android/" target="_blank" rel="noopener">Android 事件分发机制详解</a></li>
</ul>
<h2 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h2><p>　　<code>Activity</code>、<code>Dialog</code>、<code>Toast</code>里的控件，都是通过<code>WindowManager</code>来添加到屏幕上的，因此我们先来看一看该类的用法。</p>
<h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>　　接下来，从最简单的范例开始，一步步的介绍<code>WindowManager</code>类。</p>
<p><br>　　范例1：添加一个<code>TextView</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 将Activity的引用传递过去。</span></span><br><span class="line">        addViewToScreen(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewToScreen</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 首先，获取一个WindowManager对象。</span></span><br><span class="line">        WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        <span class="comment">// 然后，创建布局参数。</span></span><br><span class="line">        WindowManager.LayoutParams params = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        params.width = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        params.height = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        <span class="comment">// 接着，创建一个按钮。</span></span><br><span class="line">        Button button = <span class="keyword">new</span> Button(context);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(getApplicationContext(), <span class="string">"click"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button.setText(<span class="string">"请点击这个按钮"</span>);</span><br><span class="line">        <span class="comment">// 最后，将载入的内容放到屏幕中。</span></span><br><span class="line">        manager.addView(button, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  添加到屏幕上的View对象，既可以是使用LayoutInflater来载入一个布局文件，也可以是通过代码来new出来的View对象。
-  运行本范例时，我们就可以在屏幕的中央看到按钮了。
</code></pre><p><br>　　程序运行后就会发现一个问题：</p>
<pre><code>-  除了按钮之外屏幕上的任何东西都没法点击了。
-  这是因为，默认情况下，通过WindowManager添加到屏幕中的控件会拦截所有事件。
</code></pre><p><br>　　我们可以通过给<code>WindowManager.LayoutParams</code>类的<code>flags</code>属性设置值来解决这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params.flags =</span><br><span class="line">    WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  FLAG_NOT_FOCUSABLE表示View不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL。
-  FLAG_NOT_TOUCH_MODAL表示系统会将View区域以外的单击事件传递给底层控件，区域以内的单击事件则由View自己处理。
-  FLAG_SHOW_WHEN_LOCKED可以让Window对象显示在锁屏界面上，这个Flag需要作用到Window对象上，具体用法请自行搜索。
-  如果想为LayoutParams指定多个flag，则flag之间使用“|”间隔。
</code></pre><p><br>　　解决了这个问题之后，又发现如果我们点击<code>Home</code>键，那么屏幕上的按钮就会随着<code>Activity</code>一起被切到后台。<br>　　如果想让按钮一直显示在屏幕上，而不随着<code>Activity</code>一起隐藏，那么可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 将Activity的引用传递过去。</span></span><br><span class="line">        addViewToScreen(getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewToScreen</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        WindowManager.LayoutParams params = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;</span><br><span class="line">        <span class="comment">// 为type字段赋值。</span></span><br><span class="line">        params.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">        params.width = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        params.height = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        Button button = <span class="keyword">new</span> Button(context);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"click"</span>);</span><br><span class="line">                Toast.makeText(getApplicationContext(), <span class="string">"click"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        button.setText(<span class="string">"请点击这个按钮"</span>);</span><br><span class="line">        manager.addView(button, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  本范例中主要修改了两处代码，这两处缺一不可：
   -  将传递给addTextViewToScreen()方法的Activity对象改为Application对象。
   -  将params.type属性赋值为TYPE_PHONE。常用取值为：
      -  TYPE_PHONE ：手机级别，即表示在所有应用程序之上，但在状态栏之下。
      -  TYPE_SYSTEM_ALERT ：系统窗口级别。比如：显示电量低时弹出的Alert对话框。
      -  TYPE_SYSTEM_OVERLAY ：系统窗口之上的级别，此级别的控件无法响应点击事件。
-  创建浮动窗需要添加下面这个权限：
   -  &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;
-  如果你是小米手机则默认是无法在屏幕上添加View的，去应用程序设置里，把权限给打开即可。
</code></pre><p><br><strong>优先级</strong><br>　　事实上<code>WindowManager</code>中可以放置很多个<code>View</code>（控件），控件之间有优先级之分，<code>优先级高的将被放到优先级低的上面</code>。若最高优先级控件的宽高是<code>“MATCH_PARENT”</code>，则其下面的控件都将被完全遮住，<code>若优先级相同则后加入的会被放到上面显示</code>。<br><br>　　我们来看一下下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        addTextViewToScreen(getApplication(), WindowManager.LayoutParams.TYPE_PHONE, <span class="string">"Phone1"</span>);</span><br><span class="line">        addTextViewToScreen(getApplication(), WindowManager.LayoutParams.TYPE_PHONE, <span class="string">"Phone2"</span>);</span><br><span class="line">        addTextViewToScreen(getApplication(), WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY, <span class="string">"Overlay"</span>);</span><br><span class="line">        addTextViewToScreen(getApplication(), WindowManager.LayoutParams.TYPE_SYSTEM_ALERT, <span class="string">" Alert "</span>);</span><br><span class="line">        addTextViewToScreen(getApplication(), WindowManager.LayoutParams.TYPE_PHONE, <span class="string">"Phone3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> offsetY;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addTextViewToScreen</span><span class="params">(Context context, <span class="keyword">int</span> type, String text)</span></span>&#123;</span><br><span class="line">        WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        WindowManager.LayoutParams params = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">        params.width = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        params.height = <span class="number">70</span>;</span><br><span class="line">        params.type = type;</span><br><span class="line">        <span class="comment">// 设置View在y轴上的坐标值，相应的也可以设置x值。</span></span><br><span class="line">        params.y = offsetY;</span><br><span class="line">        offsetY += <span class="number">60</span>;</span><br><span class="line">        TextView textView = <span class="keyword">new</span> TextView(context);</span><br><span class="line">        textView.setText(text);</span><br><span class="line">        manager.addView(textView, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　程序的运行效果为：</p>
<center><br><img src="/img/android/android_b09_01.png" alt=""><br></center>

<p><br>　　从上图可以看出：</p>
<pre><code>-  Phone2与Phone1是同级别的，但是Phone2却在Phone1上面。
-  Overlay的级别最高，所以它压在了Phone2上面。
-  Alert的级别第二高，虽然是在Overlay之后添加的，但是它任然被放到了Overlay下面。
-  Phone3被压在了Alert下面。
</code></pre><p><br><strong>删除和更新</strong></p>
<p><br>　　范例1：从屏幕中移除一个已经存在的控件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windowManager.removeView(destView);</span><br></pre></td></tr></table></figure></p>
<p><br>　　范例2：更新屏幕中一个已经存在的控件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让y轴坐标偏移100个像素</span></span><br><span class="line">mParams.y += <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 依据最近的mParams中的信息（x、y、width、height等）来重新设置view的显示效果。</span></span><br><span class="line">mWindowManager.updateViewLayout(view, mParams);</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  这里所说的更新控件，其实就是更新控件的LayoutParams对象。
</code></pre><p><br></p>
<h3 id="百度安全卫士"><a href="#百度安全卫士" class="headerlink" title="百度安全卫士"></a>百度安全卫士</h3><p>　　如果你基础不错的话，通过上面学的知识，就可以模仿<code>360的小火箭特效</code>了（具体请参考郭霖的博客），笔者仿写了一个百度安全卫士内存清理动画的<code>Demo</code>，程序运行效果如下：</p>
<center><br><img src="http://img.blog.csdn.net/20150602150418233?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzI4NTU0MTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></center>

<p>　　从上图中可以看出，仿写的效果和正牌还是有一些差距的，但是通过这个<code>Demo</code>可以让大家更深刻的理解<code>WindowManager</code>类可以做哪些事情。</p>
<p>　　<a href="http://download.csdn.net/detail/github_28554183/8764099" target="_blank" rel="noopener">点击下载源码</a></p>
<p>　　如果你没有<code>Android Studio</code>环境，那么可以去<code>AndroidTest\app\build\outputs\apk</code>目录找到<code>apk</code>直接安装运行。</p>
<p><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/8689140" target="_blank" rel="noopener">Android桌面悬浮窗效果实现，仿360手机卫士悬浮窗效果</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/16919859" target="_blank" rel="noopener">Android桌面悬浮窗进阶，QQ手机管家小火箭效果实现</a></li>
</ul>
<h1 id="第二节-Hello-World"><a href="#第二节-Hello-World" class="headerlink" title="第二节 Hello World"></a>第二节 Hello World</h1><p>　　为了对自定义控件有个整体的认识，接下来我们先来写一个<code>HelloWorld</code>，其中涉及到的知识后面会详细介绍。</p>
<p><br>　　范例1：<code>MyView</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有自定义控件都必须继承View或View的子类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当通过代码来创建View对象时（通过new关键字），调用此方法初始化View。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当通过XML标签来创建View对象时，调用此方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  我们有两种方式来创建View对象：
   -  第一种，在代码中通过new关键字，直接实例化View对象。
   -  第二种，在XML中使用标签来创建View对象。
-  这两种方式分别会导致上面两个构造方法的调用。
</code></pre><p><br>　　然后，我们来重写<code>onDraw</code>方法，该方法继承自<code>View</code>类，当系统需要绘制某个<code>View</code>时，就会调用该<code>View</code>对象的<code>onDraw</code>方法执行绘制操作。</p>
<p><br>　　范例2：<code>MyView</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当通过代码来创建View对象时（通过new关键字），调用此方法初始化View。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当通过XML标签来创建View对象时，调用此方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">// 在当前控件上写一行文字。</span></span><br><span class="line">        Paint p = <span class="keyword">new</span> Paint();</span><br><span class="line">        p.setTextSize(<span class="number">72</span>);</span><br><span class="line">        canvas.drawText(<span class="string">"Hello World!!!"</span>, <span class="number">0</span>, <span class="number">100</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  对于onDraw方法里的代码，暂且知道它们的作用即可，每行代码的具体含义后面会有详细的介绍。
</code></pre><p><br>　　接着，在布局文件中使用我们自定义的控件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.cutler.demo.common.view.MyView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  使用自定义控件时，控件的名称要包含包名。
-  由于笔者将MyView放到了com.cutler.demo.common.view包中，所以才这么写。
</code></pre><p><br>　　最后，程序的运行效果如下图所示：</p>
<center><br><img src="/img/android/android_b08_05.png" alt=""><br></center>

<p><br>　　提示：</p>
<pre><code>-  在Android中，View类占据了屏幕上一个“矩形区域”，并负责绘制和处理事件。
-  从整体上来看，Activity内的所有View按照从上到下的顺序，排列成了一个“树型结构”，我们把这个树形结构称为“View树”、“视图树”。
</code></pre><h1 id="第三节-生命周期方法"><a href="#第三节-生命周期方法" class="headerlink" title="第三节 生命周期方法"></a>第三节 生命周期方法</h1><p>　　在继承了<code>View</code>类且重写完构造方法后，接着你就可以根据自己的需要来重写<code>View</code>所提供的一些回调方法了。你不需要重写所有的方法，实际上你可以从仅重写<code>onDraw(android.graphics.Canvas)</code>方法开始，但是本节将会详细讲解<code>View</code>类的各个回调方法的调用时机。</p>
<p>　　首先，要知道的是，任何一个视图都不可能凭空突然出现在屏幕上，它们都是要经过非常科学的绘制流程后才能显示出来的。<br>　　然后，当<code>Activity</code>获取焦点的时候，它就需要绘制它的<code>View树</code>了。<br>　　接着，整个<code>View树</code>会从根节点开始，依次执行绘制。<br>　　最后，每个<code>View</code>对象从创建到结束的整个生命周期中，会经历多个阶段：创建、布局、绘制、事件处理、焦点等，每个阶段中都提供了一个或多个回调方法。</p>
<h2 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h2><p>　　在<code>View</code>的创建阶段中，框架会首先调用该<code>View</code>的构造方法进行对象的初始化，通常在你自定义的<code>View</code>类中会定义两个不同的构造器，并在其内部来调用父类的构造器。</p>
<p>　　在构造方法返回之后，系统会进行如下判断： </p>
<pre><code>-  若当前控件继承自View类，则构造方法执行完毕后会接着调用它的onFinishInflate方法。
-  若当前控件继承自ViewGroup或其子类，则将在当前控件的所有子View的onFinishInflate方法都调用完成后，才会调用它的onFinishInflate方法。
</code></pre><p><br>　　<code>onFinishInflate</code>方法的一个比较常见的应用场景是：</p>
<pre><code>-  你自定义了一个ViewGroup，它支持在XML文件中使用，这就不可避免的在它的标签里包含其它子标签。
-  如果你想在代码中获取到它的子标签的引用，那么就应该在这个方法里写，而不是在构造方法里。这是因为，当ViewGroup的此方法被调用时，意味着它所包含的所有子控件也都加载完了（但只是加载完毕，宽高什么的都没测量）。
</code></pre><p><br>　　假设我们有如下的布局文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.cutler.demo.common.view.MyViewGroup</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.cutler.demo.common.view.MyView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/myView"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.cutler.demo.common.view.MyViewGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><br>　　然后，<code>MyViewGroup</code>类的代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewGroup</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyView myView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewGroup</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">        myView = (MyView) findViewById(R.id.myView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  程序运行是，会按照下面的顺序调用：
   -  首先，调用MyViewGroup的构造方法。
   -  然后，调用MyView的构造方法。
   -  接着，调用MyView的onFinishInflate方法。
   -  最后，再调用MyViewGroup的onFinishInflate方法。
</code></pre><p><br>　　注意：如果你的控件不是从<code>XML</code>中创建的（而是通过代码<code>new</code>出来的），那么不会导致<code>onFinishInflate</code>方法调用。</p>
<p><br>　　创建阶段完成后，还有三个比较重要的阶段：<code>测量</code>、<code>布局</code>、<code>绘制</code>。</p>
<h2 id="测量阶段"><a href="#测量阶段" class="headerlink" title="测量阶段"></a>测量阶段</h2><p>　　测量（<code>measure</code>）指的是对View的尺寸进行测量，因为父控件只有知道了每个子View的尺寸之后，它才能正确的摆放子View（比如防止子View重叠等）。<br>　　因此在创建完View之后，系统首先要做的就是测量View的尺寸。</p>
<p><br>　　前面已经分析过，当系统需要测量View时，会调用<code>DecorView</code>的<code>measure</code>方法，它内部的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">        <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">        onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  measure方法定义在View中，并且是final的，子类没法去重写它。
-  简单的说在measure方法内，就做了三件事：
   -  首先，在测量之前执行一些预处理操作。
   -  然后，在上面第7行代码中调用了onMeasure方法，开始正式的测量工作。
   -  最后，对测量的结果进行收尾处理。
-  由于一个View到底需要多少宽高只有它自己才知道，因此系统在View类中提供了onMeasure()方法供子类重写，你只需要在该方法内部执行测量操作即可，当然可以不重写它，因为View提供了默认的实现。
</code></pre><p><br>　　在讲解如何重写<code>onMeasure()</code>方法进行测量之前，需要先介绍一下<code>MeasureSpec</code>类。</p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>　　首先让<code>MyView</code>类重写<code>onMeasure</code>方法，但是在其内部会直接调用父类的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们不做任何操作，只是输出参数的值。</span></span><br><span class="line">        System.out.println(widthMeasureSpec + <span class="string">","</span> + heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从onMeasure方法的两个参数的名字来看，它们应该是表示宽度和高度，但是在程序运行时输出的值却是类似于：
   -  -2147482568,-2147481937
   -  1073742904,-2147481937
-  这他妈根本看不懂啊，逗爹呢？ 
</code></pre><p><br>　　其实<code>onMeasure</code>方法的两个参数虽然是<code>int</code>类型的，但是我们称它们为<code>MeasureSpec</code>：</p>
<pre><code>-  MeasureSpec是一个32位的int值，高2位代表SpecMode（测量模式），低30位代表SpecSize（测量尺寸）。
-  MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配。而且为了方便操作，MeasureSpec类提供了打包和解包的方法。
-  SpecMode和SpecSize也使用int值表示。
</code></pre><p>　　总之一句话，“系统之所以使用int值，就是为了节省内存分配，这样只需要使用1个int值就能表示两个数据”。</p>
<p><br>　　既然这两参数是混合值，那么在使用它们之前，首先得使用<code>MeasureSpec</code>类来拆分出<code>SpecMode</code>和<code>SpecSize</code>。</p>
<p>　　范例1：获取<code>mode</code>与<code>size</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取widthMeasureSpec中的mode值。</span></span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="comment">// 获取widthMeasureSpec中的size值。</span></span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　其中<code>size</code>指的是尺寸，<code>mode</code>指的是模式，常见的模式有： </p>
<pre><code>-  MeasureSpec.EXACTLY：精确尺寸。
   -  当控件的layout_width或layout_height指定为具体数值(如50dip)或FILL_PARENT时，mode的值会为EXACTLY。
   -  当mode是EXACTLY时，表示父视图希望子视图的大小应该是由size的值来决定的。
-  MeasureSpec.AT_MOST：最大尺寸。
   -  当控件的layout_width或layout_height指定为WRAP_CONTENT时，mode的值会为AT_MOST。
   -  当mode是AT_MOST时，size给出了父控件允许的最大尺寸，此时控件尺寸只要不超过父控件允许的最大尺寸即可。
-  MeasureSpec.UNSPECIFIED：未指定尺寸。
   -  这种情况比较少见，不太会用到，笔者也没搞清楚。
</code></pre><p><br>　　从上面的描述可以看出来，<code>MeasureSpec</code>的值与<code>LayoutParams</code>有关系，下面就具体介绍。</p>
<h3 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h3><p>　　当系统需要测量控件尺寸时，会从DecorView开始，从上到下依次测量View树中的每一个控件。在测量时，每一个子View的<code>onMeasure</code>方法的参数，都是由其父View传递过来的。</p>
<pre><code>父View会综合自身的情况以及子控件的LayoutParams来计算出需要传递给子控件的MeasureSpec值。
</code></pre><p><br>　　而且，DecorView和普通View的<code>MeasureSpec</code>的计算过程略有不同，我们分开来看。</p>
<p><br><strong>DecorView</strong><br>　　对于DecorView来说，它的<code>MeasureSpec</code>值是在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中计算的，代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// desiredWindowWidth和desiredWindowHeight是屏幕的尺寸</span></span><br><span class="line">childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br></pre></td></tr></table></figure></p>
<p>　　接着再看一下<code>getRootMeasureSpec</code>方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  静态方法MeasureSpec.makeMeasureSpec用来将两个普通的int值合成一个MeasureSpec值。
-  上面的代码已经表示的很清楚了，ViewRootImpl会依据DecorView的LayoutParams的值以及窗口的尺寸来计算出DecorView的MeasureSpec。
</code></pre><p><br><strong>普通View</strong><br>　　对于普通View来说，它的<code>measure</code>方法是由ViewGroup调用的，先来看一下ViewGroup的<code>measureChildWithMargins</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">            <span class="comment">// be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">            <span class="comment">// big it should be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从代码中也可以容易看出来，子View的MeasureSpec值，是由其父容器的MeasureSpec和子View的LayoutParams来确定的。
</code></pre><p><br></p>
<h3 id="开始测量"><a href="#开始测量" class="headerlink" title="开始测量"></a>开始测量</h3><p>　　稍微总结一下，我们现在知道的知识有：</p>
<pre><code>-  第一，当需要测量View的时，系统会从DecorView开始自上向下的测量每一个View。
-  第二，不论是DecorView还是普通的View，它们的MeasureSpec都是由它的上级传递过来的。
   -  对于DecorView来说，它的MeasureSpec是由屏幕的尺寸和它自身的LayoutParams决定的。
   -  对于普通View来说，它的MeasureSpec是由父View剩余空间和它自身的LayoutParams决定的。
      -  若父ViewGroup的layout_height值为100，子View的值为200，则最终传入到子View的高度就是200。
-  第三，当系统需要测量某个View时，会调用View类的onMeasure方法。
-  第四，MeasureSpec是一个复合的int值，在使用之前需要将它们拆解。
</code></pre><p><br>　　需要说的是，普通View和ViewGroup的重写onMeasure方法时是有区别的：</p>
<pre><code>-  普通View只需要在onMeasure中测量自己的尺寸即可。
-  ViewGroup除了完成自己的测量过程外，还需要遍历去调用其所有子View的measure方法，各个子View再递归去执行这个流程。
</code></pre><p><br><strong>普通View的重写</strong><br><br>　　范例1：重写<code>onMeasure</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 什么都不干，直接设置MyView的宽高为300*300像素，注意此处的单位是px，而不是dp。</span></span><br><span class="line">        setMeasuredDimension(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  当系统调用onMeasure方法时，就是在要求View执行测量了。
-  当View测量完毕时需要将测量结果给保存起来，但是由于Java方法只能返回一个值，没法同时将宽度和高度一起返回，所以系统给我们提供一个setMeasuredDimension方法，我们把测量的结果传递过去即可。
-  在实际开发中，很少会像上面那样把MyView的尺寸写死在代码上，而是会依据widthMeasureSpec和heightMeasureSpec的值来动态的计算出MyView的尺寸。
</code></pre><p><br>　　当然我们也可以不重写onMeasure方法，而是使用父类（View类）的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　总结一下<code>onMeasure</code>方法：</p>
<pre><code>-  若没有重写onMeasure方法，则会按照View类的默认方式处理：
   -  通常情况下View对象的测量尺寸就是layout_width和layout_height所设置的值。
   -  在少数情况下，View对象的测量尺寸是getSuggestedMinimumWidth和getSuggestedMinimumHeight方法返回的。
-  若重写了onMeasure方法，则View对象的测量尺寸就是你在onMeasure方法里测量的结果。
   -  但是onMeasure方法测出的宽度和高度不一定就是View最终的宽高。
   -  测量宽高会受到View对象父View的约束，若父控件最大允许的宽度为100px，但子View测量的宽度为200px，最终子控件只会显示前100px的宽度，超出的部分不会被显示，除非加上滚动条。
</code></pre><p><br>　　注意，视图实际拥有两对宽度和高度的值：</p>
<pre><code>-  第一对被称作测量宽度和测量高度。
   - 这两个尺寸表示View在其父View中需要的大小，也就是我们在onMeasure方法里计算出来的宽高。
   - 当View对象的measure()返回时，就可以通过getMeasuredWidth()和getMeasuredHeight()方法来获得测量宽高。
-  第二对被简单的称作宽度和高度，或绘制宽度和绘制高度。
   -  这两个尺寸表示View最终在屏幕上的实际大小，不过在少数情况下，绘制宽高可能与测量宽高不同。
   -  当View对象的onLayout()被调用时，就可以通过getWidth()方法和getHeight()方法来获取视图的宽高了。
</code></pre><p><br>　　说了这么多，也许你还是不知道怎么重写onMeasure方法，没关系，后面会有实战范例，不要慌！</p>
<p><br><strong>ViewGroup的重写</strong><br>　　事实上，<code>ViewGroup</code>类并没有重写<code>onMeasure</code>方法，而是交给它的子类来重写了。</p>
<p>　　下面是<code>LinearLayout</code>类的<code>onMeasure</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureVertical</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干行代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历测量每一个子View。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="comment">// 此处省略若干行代码</span></span><br><span class="line">        measureChildBeforeLayout(</span><br><span class="line">               child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</span><br><span class="line">               totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 此处省略若干行代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干行代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当所有子View都测量完毕后，再测量自己的尺寸。</span></span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">    <span class="keyword">int</span> heightSize = mTotalLength;</span><br><span class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line">    <span class="keyword">int</span> heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处省略若干行代码</span></span><br><span class="line">    </span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            heightSizeAndState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干行代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">measureChildBeforeLayout</span><span class="params">(View child, <span class="keyword">int</span> childIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> totalWidth, <span class="keyword">int</span> heightMeasureSpec, <span class="keyword">int</span> totalHeight)</span> </span>&#123;</span><br><span class="line">    measureChildWithMargins(child, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用getChildMeasureSpec方法，综合自身和当前子View的尺寸信息，计算出子View最终的测量尺寸。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　提示：父视图可能在它的子视图上调用一次以上的<code>measure(int,int)</code>方法。</p>
<h2 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h2><p>　　当所有<code>View</code>都测量完毕后，就需要设置它们的位置了，这个过程同样是从<code>DecorView</code>开始，调用的方法为<code>layout()</code>。</p>
<p><br>　　首先，我们来看下<code>View.java</code>中的<code>layout()</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用setFrame或setOpticalFrame方法来修改当前View的位置。</span></span><br><span class="line">    <span class="comment">// 注意：这个位置是当前控件在父View内的相对位置，原点是父View的左上角。</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        <span class="comment">// 如果上面修改成功了，或者用户强制要求更新，则回调onLayout()方法。</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="comment">// 回调所有注册过的（如果有的话）listener的onLayoutChange()方法。</span></span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从第3行代码可以看出来，在View的layout阶段也有可能调用onMeasure方法。
</code></pre><p><br>　　关于<code>onLayout()</code>方法：</p>
<pre><code>-  当需要确定当前View的所有子View的位置时，才会调用onLayout方法。
-  对于普通的View类来说，由于它是没有子View的，因此View类的onLayout()只是一个空实现。
-  对于ViewGroup类来说，在它内部onLayout方法被改为抽象方法了，所有ViewGroup的子类都必须重写它。
</code></pre><p><br>　　接着我们来看下<code>ViewGroup.java</code>中的<code>layout()</code>和<code>onLayout()</code>方法的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTransition.layoutChange(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// record the fact that we noop'd it; request layout when transition finishes</span></span><br><span class="line">        mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  相比之下ViewGroup增加了LayoutTransition的处理：
   -  若当前ViewGroup未添加LayoutTransition动画，或动画未运行，则调用super.layout(l,t,r,b)。
   -  否则将mLayoutCalledWhileSuppressed设置为true，等待动画完成时再调用requestLayout()。
-  除此之外，还有两个地方需要注意：
   -  layout()方法增加了final关键字，这意味着它的所有子类无法重写layout()方法。
   -  onLayout()方法使用abstract关键字修饰了，这意味着它的所有子类必须重写此方法。
</code></pre><p><br>　　我们来看下<code>LinearLayout</code>的<code>onLayout</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  参数 changed 表示当前ViewGroup的尺寸或者位置是否发生了改变。</span></span><br><span class="line"><span class="comment">//  也就是说ViewGroup的尺寸和位置没有发生变化时，此方法也有可能被调用。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 依据方向来调用不同的方法进行layout。</span></span><br><span class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">        layoutVertical(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutHorizontal(l, t, r, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 此处省略若干行代码</span></span><br><span class="line">    <span class="keyword">int</span> childTop;</span><br><span class="line">    <span class="keyword">int</span> childLeft;</span><br><span class="line">    <span class="comment">// 此处省略若干行代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            childTop += measureNullChild(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="comment">// 获取到我们之前测量出来的尺寸。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">            <span class="comment">// 此处省略若干行代码</span></span><br><span class="line">            <span class="comment">// 调用setChildFrame()方法来设置子控件的位置</span></span><br><span class="line">            setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);</span><br><span class="line">            <span class="comment">// 由于是垂直排列元素，因此这里需要更新childTop变量的值，以便下一个子View进行布局。</span></span><br><span class="line">            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;        </span><br><span class="line">    child.layout(left, top, left + width, top + height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从第23行代码可以看出，LinearLayout的子View最终的显示的宽和高，是由该子View的measure过程的结果来决定的。
-  因此measure过程的意义就是为layout过程提供视图显示范围的参考值。
</code></pre><h2 id="绘画阶段"><a href="#绘画阶段" class="headerlink" title="绘画阶段"></a>绘画阶段</h2><p>　　布局阶段执行完毕后，框架就会调用DecorView的<code>draw()</code>方法开始绘制<code>View树</code>。但是每次绘图时，并不会重新绘制整个<code>View树</code>中的所有<code>View</code>，而只会重新绘制那些<code>“需要重绘”</code>的<code>View</code>，<code>View</code>类内部变量包含了一个标志位<code>DRAWN</code>，当该视图需要重绘时，就会为该<code>View</code>添加该标志位。</p>
<p><br>　　通过查看源码可以知道，View类的绘制流程由六步构成：</p>
<pre><code>-  第一，绘制当前View的背景。
-  第二，如果有必要，则为稍后绘制渐变效果做一些准备操作(大多数情况下，不需要)。
-  第三，调用onDraw()方法绘制视图本身。
   -  View类的onDraw()方法是空实现，ViewGroup类没有重写此方法。
-  第四，调用dispatchDraw()方法绘制子视图。
   -  View类的dispatchDraw()方法是空实现，因为对于不包含子View的控件来说不需要重写此方法。
   -  ViewGroup类已经为我们重写了dispatchDraw()的功能实现，因此ViewGroup的子类一般不需要重写该方法。
-  第五，如果第二步被执行了，那么第五步也会被执行。第五步用来绘制渐变效果以及绘制渐变效果之后的一些收尾工作。
-  第六，绘制滚动条。
   -  在Android中不管是Button还是TextView，任何一个视图都是有滚动条的，只是一般情况下我们都没有让它显示出来而已。
</code></pre><p><br>　　总而言之，每一个具体的<code>View</code>都应该重写<code>onDraw()</code>方法，并且不论是<code>View</code>还是<code>ViewGroup</code>的子类，一般不需要重写<code>dispatchDraw()</code>方法。</p>
<p>　　绘制的时候主要是借助<code>Canvas</code>这个类，它会作为参数传入到<code>onDraw()</code>方法中，供给每个视图使用。<br>　　<code>Canvas</code>这个类的用法非常丰富，基本可以把它当成一块画布，在上面绘制任意的东西，那么我们就来尝试一下吧。</p>
<p><br>　　范例1：初步使用画笔和画布。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置画笔颜色为黄色</span></span><br><span class="line">        mPaint.setColor(Color.YELLOW);</span><br><span class="line">        <span class="comment">// 使用画笔绘制一个黄色的矩形</span></span><br><span class="line">        canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), mPaint);</span><br><span class="line">        <span class="comment">// 设置画笔颜色为蓝色</span></span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">        <span class="comment">// 设置画笔的字体大小</span></span><br><span class="line">        mPaint.setTextSize(<span class="number">20</span>);</span><br><span class="line">        String text = <span class="string">"Hello View"</span>;</span><br><span class="line">        <span class="comment">// 将一行文本绘制到画布中去，字体的颜色是蓝色，字体的大小是20px。</span></span><br><span class="line">        canvas.drawText(text, <span class="number">0</span>, getHeight() / <span class="number">2</span>, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　布局文件的内容为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.cutler.demo.common.view.MyView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  Paint表示一个画笔，Canvas表示一个画布。 
-  另外，由于MyView类没有重写onMeasure方法，则系统使用默认的策略来计算它的测量尺寸，即使用XML中设置的尺寸。
</code></pre><p>　　运行效果如下图所示：</p>
<center><br><img src="http://img.blog.csdn.net/20131223234856718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></center>

<p><br><strong>View重绘</strong><br>　　虽然View会在<code>Activity</code>加载完成之后绘制到屏幕上，但是在程序的运行时View的状态是会改变的。当改变发生时，之前绘制出的内容其实就已经过期了，此时应该对视图进行重绘。</p>
<p>　　调用视图的<code>setVisibility()</code>、<code>setEnabled()</code>、<code>setSelected()</code>等方法时都会导致视图重绘，而如果我们想要手动地强制让视图进行重绘，可以调用<code>invalidate()</code>方法来实现。</p>
<pre><code>-  setVisibility、setEnabled、setSelected等方法的内部其实也是通过调用invalidate方法来实现的。
-  这里的重绘是指谁请求invalidate方法，就重绘该视图(View的话只绘制该View，ViewGroup则绘制整个ViewGroup)。
</code></pre><p>　　<code>invalidate()</code>只可以在主线程中调用，如果你需要在子线程中重绘<code>View</code>，那么可以调用<code>postInvalidate()</code>方法。</p>
<p><br>　　如果你需要<code>定时重绘</code>，那么你可以使用<code>postInvalidateDelayed(long delayMilliseconds)</code>方法，当倒计时结束后，该方法会有如下判断：</p>
<pre><code>-  若调用该方法的View依然显示在屏幕中，则该方法会在主线程中调用invalidate()方法执行重绘。
-  若调用该方法的View已经不显示了，则这个重绘任务会被挂起，等到该View再次显示时，才会触发重绘。
</code></pre><p>　　比如，对于一个计时器<code>View</code>来说，每秒钟都需要重绘一次，如果通过开启<code>Thread</code>来定时调用<code>postInvalidate()</code>方法来实现计时的话，有两个缺点：</p>
<pre><code>-  第一，开启Thread类需要消耗一定资源。
-  第二，若计时器View当前不再屏幕中（比如用户把App切换到后台了），那么线程仍然在跑，View仍然是每秒钟都重绘一次，浪费大量资源。
</code></pre><p><br>　　如果你不需要<code>定时重绘</code>，那么最好也去使用<code>postInvalidate()</code>方法，当<code>View</code>不再显示时，它同样不会立刻执行重绘操作，它的源码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postInvalidateDelayed(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="其它常用方法"><a href="#其它常用方法" class="headerlink" title="其它常用方法"></a>其它常用方法</h2><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>　　<code>View</code>的几何形状是<code>矩形</code>的，视图的<code>位置</code>使用<code>左上坐标系</code>表示，<code>尺寸</code>由<code>宽和高</code>表示，位置和尺寸以<code>像素</code>为单位。我们可以通过<code>getLeft()</code>和<code>getTop()</code>函数取得视图的位置：</p>
<pre><code>-  前者返回视图的左侧位置（横坐标X）。
-  后者返回视图的顶部位置（纵坐标Y）。
</code></pre><p>　　这两个方法返回视图相对于其父视图的位置，例如<code>getLeft()</code>返回<code>20</code>，代表视图在其直接父视图左侧边的右侧<code>20</code>像素的位置。</p>
<p>　　另外，为了避免不必要的计算，提供了一些便利的方法，它们是<code>getRight()</code>和<code>getBottom()</code>。这些方法返回代表视图的矩形的右侧和底边的坐标。例如，调用<code>getRight()</code>比调用<code>getLeft() + getWidth()</code>要简单。</p>
<h3 id="跳过绘制"><a href="#跳过绘制" class="headerlink" title="跳过绘制"></a>跳过绘制</h3><p>　　<code>View</code>类有一个特殊的方法setWillNotDraw，先来看一下的它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If this view doesn't do any drawing on its own, set this flag to</span></span><br><span class="line"><span class="comment"> * allow further optimizations. By default, this flag is not set on</span></span><br><span class="line"><span class="comment"> * View, but could be set on some View subclasses such as ViewGroup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Typically, if you override &#123;<span class="doctag">@link</span> #onDraw(android.graphics.Canvas)&#125;</span></span><br><span class="line"><span class="comment"> * you should clear this flag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> willNotDraw whether or not this View draw on its own</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从注释可以看出来，如果一个View不需要绘制任何内容，那么设置这个标记位为true后，系统就会进行相应的优化。
-  默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个标记位。
</code></pre><h3 id="从窗口中添加和移除"><a href="#从窗口中添加和移除" class="headerlink" title="从窗口中添加和移除"></a>从窗口中添加和移除</h3><p>　　当View和其所在的Activity建立和断开连接时，系统会调用如下两个方法：</p>
<pre><code>-  Activity关闭或者View从Activity中移除时，View的onDetachedFromWindow方法会被调用。
   -  通常在此方法中关闭线程和停止动画，从而避免内存泄漏。
-  View被添加到Activity中时，它的onAttachedToWindow方法会被调用。
</code></pre><h3 id="大小改变"><a href="#大小改变" class="headerlink" title="大小改变"></a>大小改变</h3><p>　　在<code>View</code>类中还有一个比较有用的方法是<code>onSizeChanged</code>，当<code>View</code>的尺寸改变时就会调用它。</p>
<pre><code>-  一般情况下，我们在自定义控件的时候会依据View的尺寸来确定绘制的大小，但是程序在运行的时候不可避免的因为一些外力而导致View的尺寸发生变化（比如横竖屏切换、输入法弹出等）。
</code></pre><p>　　因此通常的做法是重写<code>onSizeChanged</code>方法，并在其内部更新变量的值，并调用<code>invalidate</code>方法进行重绘。<br><br></p>
<p><br><strong>本章参考阅读：</strong></p>
<ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/12921889" target="_blank" rel="noopener">Android LayoutInflater原理分析，带你一步步深入了解View(一)</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/16330267" target="_blank" rel="noopener">Android视图绘制流程完全解析，带你一步步深入了解View(二)</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/17045157" target="_blank" rel="noopener">Android视图状态及重绘流程分析，带你一步步深入了解View(三)</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/17357967" target="_blank" rel="noopener">Android自定义View的实现方法，带你一步步深入了解View(四)</a></li>
<li><a href="http://blog.csdn.net/jewleo/article/details/39547631" target="_blank" rel="noopener">Android如何绘制视图，解释了为何onMeasure有时要调用多次</a></li>
<li><a href="http://developer.android.com/guide/topics/ui/how-android-draws.html" target="_blank" rel="noopener">How Android Draws Views</a></li>
<li><a href="http://www.cnblogs.com/xilinch/archive/2012/10/24/2737248.html" target="_blank" rel="noopener">Android中layout过程详解</a></li>
</ul>
<p><br><br></p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechatpay.jpg" alt="乐信圣文 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/android-F03/" rel="next" title="进阶篇　第三章 消息机制与线程池">
                <i class="fa fa-chevron-left"></i> 进阶篇　第三章 消息机制与线程池
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/android-D03/" rel="prev" title="媒体篇　第三章 动画">
                媒体篇　第三章 动画 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="android-G01/"
     data-title="自定义控件篇　第一章 基础入门"
     data-content=""
     data-url="http://yoursite.com/android-G01/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="android-G01/"
           data-title="自定义控件篇　第一章 基础入门" data-url="http://yoursite.com/android-G01/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="乐信圣文" />
          <p class="site-author-name" itemprop="name">乐信圣文</p>
          <p class="site-description motion-element" itemprop="description">集大家之成，悟小家之道。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">51</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="http://www.gov.cn/" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://weishu.me/" title="weishu" target="_blank">weishu</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://ryanhoo.github.io/" title="ryanhoo" target="_blank">ryanhoo</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一节-Activity的组成"><span class="nav-number">1.</span> <span class="nav-text">第一节 Activity的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Window"><span class="nav-number">1.1.</span> <span class="nav-text">Window</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WindowManagerService"><span class="nav-number">1.2.</span> <span class="nav-text">WindowManagerService</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WindowManager"><span class="nav-number">1.3.</span> <span class="nav-text">WindowManager</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础用法"><span class="nav-number">1.3.1.</span> <span class="nav-text">基础用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#百度安全卫士"><span class="nav-number">1.3.2.</span> <span class="nav-text">百度安全卫士</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二节-Hello-World"><span class="nav-number">2.</span> <span class="nav-text">第二节 Hello World</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三节-生命周期方法"><span class="nav-number">3.</span> <span class="nav-text">第三节 生命周期方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建阶段"><span class="nav-number">3.1.</span> <span class="nav-text">创建阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测量阶段"><span class="nav-number">3.2.</span> <span class="nav-text">测量阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MeasureSpec"><span class="nav-number">3.2.1.</span> <span class="nav-text">MeasureSpec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LayoutParams"><span class="nav-number">3.2.2.</span> <span class="nav-text">LayoutParams</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始测量"><span class="nav-number">3.2.3.</span> <span class="nav-text">开始测量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布局阶段"><span class="nav-number">3.3.</span> <span class="nav-text">布局阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绘画阶段"><span class="nav-number">3.4.</span> <span class="nav-text">绘画阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其它常用方法"><span class="nav-number">3.5.</span> <span class="nav-text">其它常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定位"><span class="nav-number">3.5.1.</span> <span class="nav-text">定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳过绘制"><span class="nav-number">3.5.2.</span> <span class="nav-text">跳过绘制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从窗口中添加和移除"><span class="nav-number">3.5.3.</span> <span class="nav-text">从窗口中添加和移除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大小改变"><span class="nav-number">3.5.4.</span> <span class="nav-text">大小改变</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乐信圣文</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cutler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("sGcgYofeKOFi2l1XvGrm0PcP-gzGzoHsz", "Sx0mWxj4pkXYm17zT0UnV5Ca");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
