<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="http://www.gov.cn/" title="乐信圣文" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="本章将介绍一下Android中的各类输入事件。　　本章主要参考书籍：《Android开发艺术探索》和《Android群英传》，同时加上了笔者自己的体会。 第一节 基础知识　　我们先来介绍两个基础知识。 事件类型　　在Android中View类支持监听如下五种输入事件，我们可以通过设置监听器来监听事件： -  点击事件：当用户点击一个View（如Button）时，系统会产生点击事件，并传递给该V">
<meta property="og:type" content="article">
<meta property="og:title" content="UI篇 第五章 自定义控件 - 输入事件">
<meta property="og:url" content="http://yoursite.com/android-ui-005/index.html">
<meta property="og:site_name" content="乐信圣文">
<meta property="og:description" content="本章将介绍一下Android中的各类输入事件。　　本章主要参考书籍：《Android开发艺术探索》和《Android群英传》，同时加上了笔者自己的体会。 第一节 基础知识　　我们先来介绍两个基础知识。 事件类型　　在Android中View类支持监听如下五种输入事件，我们可以通过设置监听器来监听事件： -  点击事件：当用户点击一个View（如Button）时，系统会产生点击事件，并传递给该V">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-01-20T07:23:43.791Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UI篇 第五章 自定义控件 - 输入事件">
<meta name="twitter:description" content="本章将介绍一下Android中的各类输入事件。　　本章主要参考书籍：《Android开发艺术探索》和《Android群英传》，同时加上了笔者自己的体会。 第一节 基础知识　　我们先来介绍两个基础知识。 事件类型　　在Android中View类支持监听如下五种输入事件，我们可以通过设置监听器来监听事件： -  点击事件：当用户点击一个View（如Button）时，系统会产生点击事件，并传递给该V">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/android-ui-005/"/>

  <title> UI篇 第五章 自定义控件 - 输入事件 | 乐信圣文 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?53b4b0b5aeb5df5e4fb6263a58d8e1a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">乐信圣文</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-feedback">
          <a href="/feedback" rel="section">
            
            联系我们
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                UI篇 第五章 自定义控件 - 输入事件
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            
              <span class="post-meta-item-text">Cutler</span>
            
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-27T14:53:50+08:00" content="2015-01-27">
              2015-01-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android-01-初级开发/" itemprop="url" rel="index">
                    <span itemprop="name">Android - 01 - 初级开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          

          
          
             <span id="/android-ui-005/" class="leancloud_visitors" data-flag-title="UI篇 第五章 自定义控件 - 输入事件">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>　　本章将介绍一下<code>Android</code>中的各类输入事件。<br>　　本章主要参考书籍：<a href="http://item.jd.com/1710650057.html" target="_blank" rel="noopener">《Android开发艺术探索》</a>和<a href="http://item.jd.com/11758334.html" target="_blank" rel="noopener">《Android群英传》</a>，同时加上了笔者自己的体会。</p>
<h1 id="第一节-基础知识"><a href="#第一节-基础知识" class="headerlink" title="第一节 基础知识"></a>第一节 基础知识</h1><p>　　我们先来介绍两个基础知识。</p>
<p><br><strong>事件类型</strong><br>　　在<code>Android</code>中<code>View</code>类支持监听如下<code>五种</code>输入事件，我们可以通过设置监听器来监听事件：</p>
<pre><code>-  点击事件：当用户点击一个View（如Button）时，系统会产生点击事件，并传递给该View。
   -  调用View的setOnClickListener方法来监听此事件。
-  长按事件：当用户长时间按住一个View时，系统会产生长按事件，并传递给该View。
   -  调用View的setOnLongClickListener方法来监听此事件。
-  焦点改变事件：当用户使用导航键或滚迹球将输入焦点导入或导出某个View时，系统会产生焦点改变，并传递给该View。
   -  调用View的setOnFocusChangeListener方法来监听此事件。
-  按键事件：当用户让输入焦点落到某个View上，并且按下或释放设备上的一个按键时，系统会产生按键事件，并传递给该View。
   -  调用View的setOnKeyListener方法来监听此事件。
-  触摸事件：当用户手指触摸某个View时，系统会产生触摸事件，并传递给该View。
   -  调用View的setOnTouchListener方法来监听此事件。
</code></pre><p><br>　　比如，下面代码展示了如何给一个<code>Button</code>注册一个<code>View.OnClickListener</code>监听器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button) findViewById(R.id.button_send);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something in response to button click</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>　　你可能也发现把<code>OnClickListener</code>作为Activity的一部分来实现会更方便。这样会避免类的加载和对象空间的分配。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedValues)</span> </span>&#123;</span><br><span class="line">        Button button = (Button)findViewById(R.id.corky);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　如果我们想监听系统内置控件的事件，那么只能使用上面这种调用<code>setXxx</code>设置监听器。但是，若控件是我们自己创建的，那就可以通过重写下面的方法来监听事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当一个键被按下时，会调用这个方法；</span></span><br><span class="line">onKeyDown(<span class="keyword">int</span>, KeyEvent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个被按下的键弹起时，会调用这个方法；</span></span><br><span class="line">onKeyUp(<span class="keyword">int</span>, KeyEvent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当轨迹球滚动时，会调用这个方法；</span></span><br><span class="line">onTrackballEvent(MotionEvent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个View对象获得或失去焦点时，会调用这个方法。</span></span><br><span class="line">onFoucusChanged(Boolean, <span class="keyword">int</span>, Rect)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸事件</span></span><br><span class="line">onTouchEvent(MotionEvent event)</span><br></pre></td></tr></table></figure></p>
<p><br>　　上面列出的五种事件中，相对来说<code>触摸事件稍显复杂</code>，本章会重点介绍触摸事件。</p>
<p><br><strong>触摸模式</strong><br>　　对于一个有触摸能力的设备，一旦用户触摸屏幕，这个设备就会进入<code>触摸模式(touch mode)</code>。<br>　　任何时刻，只要用户点击了一个<code>方向键</code>（比如Android电视的遥控器）或滚动了<code>鼠标滚轮</code>，设备就会退出触摸模式，同时系统会查找一个需要焦点的View对象，并给予其焦点（高亮显示）。<br>　　触摸模式状态是被整个系统管理的，我们可以调用<code>View#isInTouchMode()</code>来查看设备当前是否是触摸模式。</p>
<h1 id="第二节-触摸事件"><a href="#第二节-触摸事件" class="headerlink" title="第二节 触摸事件"></a>第二节 触摸事件</h1><p>　　触摸事件在开发中是最常见的，也是最容易让人搞混的，因此从本节开始将详细介绍触摸事件。</p>
<h2 id="滑动位置"><a href="#滑动位置" class="headerlink" title="滑动位置"></a>滑动位置</h2><p>　　在开发中，比较常见的一个需求：让View能随着用户的手指而拖动，要实现这个功能就需要监听View的触摸事件。</p>
<p>　　示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button) <span class="keyword">this</span>.findViewById(R.id.img);</span><br><span class="line">button.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br>　　为了了解<code>onTouch</code>方法，我们先来看看<code>View.OnTouchListener</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  描述：当View被用户“触摸”时，会调用此回调方法。</span></span><br><span class="line"><span class="comment">//  参数：</span></span><br><span class="line"><span class="comment">//       v：     被触摸的组件。</span></span><br><span class="line"><span class="comment">//       event： 表示一个触摸事件，其内封装了与“触摸事件”有关的数据。如：用户手指在屏幕的X、Y坐标等。</span></span><br><span class="line"><span class="comment">//  返回值：用于告知Android系统，当前事件是否被成功处理。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span></span></span><br></pre></td></tr></table></figure></p>
<p>　　其中<code>MotionEvent</code>类用来表示<code>“触摸事件”</code>，触摸事件有如下三个常见的状态：</p>
<pre><code>-  ACTION_DOWN：表示手指按在了View上。
-  ACTION_MOVE：表示手指按下后(此时手指没有抬起)，接着在View上拖动手指。
-  ACTION_UP：表示手指从View上抬起。
</code></pre><p>　　正常情况下，一次手指触摸屏幕的行为会触发一系列的触摸事件，最常见的是如下两种情况：</p>
<pre><code>-  点击屏幕后立刻松开，事件序列为：ACTION_DOWN -&gt; ACTION_UP。
-  点击屏幕后滑动一会再松开，事件序列为：ACTION_DOWN -&gt; ACTION_MOVE -&gt; …… -&gt; ACTION_MOVE -&gt; ACTION_UP。
</code></pre><p>　　在继续向下进行之前，先介绍一个名词<code>“事件序列”</code>。<br><br><strong>事件序列</strong><br>　　同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件。通常这个事件序列以<code>ACTION_DOWN</code>事件开始，中间含有数量不定的<code>ACTION_MOVE</code>事件，最终以<code>ACTION_UP</code>事件结束。</p>
<p><br>　　范例1：MotionEvent类的常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  描述：获取当前产生的事件的类型，常见的取值有：ACTION_DOWN、ACTION_MOVE、ACTION_UP。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  当在View产生了MotionEvent事件时，这两个方法可以获取用户手指相对于该View的左上角坐标的偏移量。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  当在View产生了MotionEvent事件时，这两个方法可以获取用户手指相对于屏幕左上角坐标的偏移量。</span></span><br><span class="line"><span class="comment">//  屏幕左上角就是状态栏的左上角的那个点。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">getRawX</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">getRawY</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><br>　　最后，下面给出一个完整的范例，如果你感觉看不懂，那就请去阅读其它人的教程，学会了触摸事件后，再回来继续。</p>
<p><br>　　范例2：通过<code>getX()</code>和<code>getY()</code>移动按钮。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Button button = (Button) findViewById(R.id.btn);</span><br><span class="line">        button.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> lastX, lastY;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();  <span class="comment">// 获取手指在Button上的位置。</span></span><br><span class="line">                <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">                <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                        lastX = x;           <span class="comment">// 保存手指按下时的位置。</span></span><br><span class="line">                        lastY = y;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                        <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">                        <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">                        <span class="comment">// 调用layout方法更新View的位置。</span></span><br><span class="line">                        button.layout(button.getLeft() + offsetX, button.getTop() + offsetY,</span><br><span class="line">                                button.getRight() + offsetX, button.getBottom() + offsetY);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  通过本范例看出，我们可以手工调用View的layout方法来更新位置，在其内部会调用invalidate进行重绘。
-  需要注意的是本范例中，只有当手指按下的时候才会保存位置，手指移动时并不会。
</code></pre><p><br>　　范例3：通过<code>getRawX()</code>和<code>getRawY()</code>移动按钮。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Button button = (Button) findViewById(R.id.btn);</span><br><span class="line">        button.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> lastX, lastY;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getRawX();  <span class="comment">// 获取手指在屏幕上的位置。</span></span><br><span class="line">                <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getRawY();</span><br><span class="line">                <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                        lastX = x;</span><br><span class="line">                        lastY = y;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                        <span class="keyword">int</span> offsetX = x - lastX;</span><br><span class="line">                        <span class="keyword">int</span> offsetY = y - lastY;</span><br><span class="line">                        button.layout(button.getLeft() + offsetX, button.getTop() + offsetY,</span><br><span class="line">                                button.getRight() + offsetX, button.getBottom() + offsetY);</span><br><span class="line">                        <span class="comment">// 此处需要保存x、y的值。</span></span><br><span class="line">                        lastX = x;</span><br><span class="line">                        lastY = y;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  再次强调本范例与范例2的区别，本范例中在手指移动的时候需要保存位置，具体原因请自己思考。
-  提示：                要啥提示？动动脑子吧。
</code></pre><p><br>　　也可以通过修改View的<code>LayoutParams</code>来改变View的位置，只需要把<code>范例3</code>的第<code>22</code>行代码替换为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) button.getLayoutParams();</span><br><span class="line">params.leftMargin += offsetX;</span><br><span class="line">params.topMargin += offsetY;</span><br><span class="line">button.setLayoutParams(params);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="滑动内容"><a href="#滑动内容" class="headerlink" title="滑动内容"></a>滑动内容</h2><p>　　在Android中，对于一个View来说它有两种类型滑动：</p>
<pre><code>-  第一种，View本身的位置发生变化（即上面一节介绍的知识）。
-  第二种，View的内容发生变化。
   -  比如当LinearLayout的子元素的尺寸超过了LinearLayout的尺寸，那么超出的部分默认是无法显示的。
   -  不过Android中所有的View的内容都是可以滑动的，也就是说可以通过滑动LinearLayout的内容，来让被隐藏的部分显示出来。
</code></pre><p>　　本节就是来介绍如何滑动View的内容。</p>
<p><br><strong>使用scrollTo和scrollBy方法</strong><br>　　为了实现<code>View</code>内容的滑动，<code>View</code>类提供了专门的方法来实现这个功能，那就是<code>scrollTo</code>和<code>scrollBy</code>，它们的源码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Set the scrolled position of your view. This will cause a call to</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span></span><br><span class="line"><span class="comment">  * invalidated.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x the x position to scroll to</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> y the y position to scroll to</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">         <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">         <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">         mScrollX = x;</span><br><span class="line">         mScrollY = y;</span><br><span class="line">         invalidateParentCaches();</span><br><span class="line">         onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">         <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">             postInvalidateOnAnimation();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Move the scrolled position of your view. This will cause a call to</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span></span><br><span class="line"><span class="comment">  * invalidated.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x the amount of pixels to scroll by horizontally</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> y the amount of pixels to scroll by vertically</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">     scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>　　可以看出来，其中<code>scrollBy</code>转调用了<code>scrollTo</code>方法，它实现了基于当前位置的相对滑动，而<code>scrollTo</code>则实现了基于所传递参数的绝对滑动。</p>
<p><br>　　使用范例，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">// 每次点击时，都使当前View的内容，在x轴方向滑动30像素。</span></span><br><span class="line">        setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                scrollBy(<span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">        paint.setColor(Color.WHITE);</span><br><span class="line">        StringBuilder sub = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sub.append(<span class="string">"11111111111111111111111111111111"</span>);</span><br><span class="line">        sub.append(<span class="string">"22222222222222222222222222222222"</span>);</span><br><span class="line">        sub.append(<span class="string">"33333333333333333333333333333333"</span>);</span><br><span class="line">        sub.append(<span class="string">"44444444444444444444444444444444"</span>);</span><br><span class="line">        sub.append(<span class="string">"55555555555555555555555555555555"</span>);</span><br><span class="line">        canvas.drawText(sub.toString(), <span class="number">0</span>, <span class="number">100</span>, paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  有两点需要注意：
   -  第一，scrollBy和scrollTo滑动的是View的内容，而不是View本身的位置。
   -  第二，scrollBy和scrollTo滑动是瞬间完成的，没有滚动时的滑翔效果。
-  调用View类的getScrollX()和getScrollY()方法可以获取View的滚动条的当前位置。
</code></pre><p><br><strong>Scroller</strong><br>　　使用<code>scrollBy</code>和<code>scrollTo</code>的滑动是瞬间完成的，效果比较生硬，为了给用户流畅的体验，可以把一次大的滑动分成若干个小的滑动，并在若干时间内完成。<br>　　我们通过<code>Scroller</code>类就可以实现动画滑动的任务。</p>
<p><br>　　修改后的范例，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        setBackgroundColor(Color.BLACK);</span><br><span class="line">        setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 第一步，先为Scroller对象设置滚动参数。</span></span><br><span class="line">                <span class="comment">//        参数依次为：滚动条当前X轴位置、Y轴位置、X轴位移长度、Y轴位移长度、多少毫秒内完成滚动。</span></span><br><span class="line">                mScroller.startScroll(getScrollX(), getScrollY(), <span class="number">30</span>, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 第二步，设置完参数后，调用invalidate方法，触发View的重绘。</span></span><br><span class="line">                invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scroller mScroller = <span class="keyword">new</span> Scroller(getContext());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当View被重绘时，系统会回调View类的此方法，计算滚动条的当前位置。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法computeScrollOffset会依据时间的流逝，来计算Scroller当前所处的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">            <span class="comment">// 让当前View的滚动条，滚动到Scroller对象当前的位置。</span></span><br><span class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">            <span class="comment">// 再次出发重绘，直到Scroller对象滚动到终点（即computeScrollOffset返回false）才停止。</span></span><br><span class="line">            <span class="comment">// 这样一来，就实现了动画滚动的效果了。</span></span><br><span class="line">            postInvalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">        paint.setColor(Color.WHITE);</span><br><span class="line">        StringBuilder sub = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sub.append(<span class="string">"11111111111111111111111111111111"</span>);</span><br><span class="line">        sub.append(<span class="string">"22222222222222222222222222222222"</span>);</span><br><span class="line">        sub.append(<span class="string">"33333333333333333333333333333333"</span>);</span><br><span class="line">        sub.append(<span class="string">"44444444444444444444444444444444"</span>);</span><br><span class="line">        sub.append(<span class="string">"55555555555555555555555555555555"</span>);</span><br><span class="line">        canvas.drawText(sub.toString(), <span class="number">0</span>, <span class="number">100</span>, paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  Scroller的startScroll方法里面什么都没有做，只是记录了一下传递过来的参数。
-  Scroller对象只是用来协助计算滚动条的位置的，它本身无法使View的内容滚动，它需要和View类的computeScroll、scrollTo、scrollBy方法配合使用。
</code></pre><p><br>　　另外，<code>Android3.0</code>中提出的属性动画也可以完成<code>Scroller</code>的功能，具体请参阅<a href="http://cutler.github.io/android-D03/" target="_blank" rel="noopener">《媒体篇　第三章 动画》</a>。</p>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p><br><strong>TouchSlop</strong><br>　　<code>TouchSlop</code>是系统所能识别出的被认为是滑动的最小距离。换句话说，当手指在屏幕上滑动时，如果两次滑动之间的距离小于这个值，那么系统就不认为它是滑动。</p>
<p>　　通过下面的代码可以获取这个值，返回值的单位是<code>px</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewConfiguration.get(getApplicationContext()).getScaledTouchSlop()</span><br></pre></td></tr></table></figure></p>
<p>　　我们在处理滑动时，可以利用它来做一些过滤，即滑动距离小于这个值时就不认为是滑动，这样可以有更好的用户体验。</p>
<p><br><strong>VelocityTracker</strong><br>　　速度追踪器（<code>VelocityTracker</code>）用于追踪手指在屏幕上的滑动速度，它的使用方法很简单：<br>　<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ******* 第一步，获取一个VelocityTracker对象：</span></span><br><span class="line">VelocityTracker mTracker = VelocityTracker.obtain();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ******* 第二步，在onTouchEvent方法中添加如下代码，记录每一个触摸事件：</span></span><br><span class="line">mTracker.addMovement(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ******* 第三步，在ACTION_UP事件发生时，使用如下执行计算操作。</span></span><br><span class="line"><span class="comment">// 以当前mTracker对象中收集的所有MotionEvent对象为基础，计算出手指1秒所能滑动的像素数量，并将它们保存起来。</span></span><br><span class="line">mTracker.computeCurrentVelocity(<span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// ******* 第四步，获取上面计算出的速度：</span></span><br><span class="line">mTracker.getXVelocity();  <span class="comment">// 水平方向。</span></span><br><span class="line">mTracker.getYVelocity();  <span class="comment">// 垂直方向。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ******* 第五步，释放资源：</span></span><br><span class="line">mTracker.recycle();</span><br><span class="line">mTracker = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p>
<p><br>　　完整的范例，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VelocityTracker mTracker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTracker = VelocityTracker.obtain();</span><br><span class="line">        &#125;</span><br><span class="line">        mTracker.addMovement(event);</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                mTracker.computeCurrentVelocity(<span class="number">1000</span>);</span><br><span class="line">                String message = <span class="string">"不算滑动"</span>;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(mTracker.getXVelocity()) &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">                    message = (mTracker.getXVelocity() &gt; <span class="number">0</span> ? <span class="string">"从左到右滑动"</span> : <span class="string">"从右到左滑动"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Toast.makeText(getContext(), message, Toast.LENGTH_SHORT).show();</span><br><span class="line">                mTracker.recycle();</span><br><span class="line">                mTracker = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  本范例只是演示VelocityTracker的使用方法，更实用的案例后面会介绍。
</code></pre><p><br><strong>GestureDetector</strong><br>　　通过重写<code>onTouchEvent</code>方法来实现一些复杂的手势（比如双击、长按等）会很麻烦。<br>　　幸运的是，<code>Android SDK</code>给我们提供了一个手势识别的类——<code>GestureDetector</code>，通过这个类我们可以识别很多的手势。</p>
<p>　　它的使用方法也很简单，直接看代码吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GestureDetector mGestureDetector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GestureDetector.OnGestureListener onGestureListener = </span><br><span class="line">                <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当手指长按时回调此方法。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GestureDetector.OnDoubleTapListener onDoubleTapListener = </span><br><span class="line">                <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapConfirmed</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当单击时回调此方法。</span></span><br><span class="line">            <span class="comment">// 与onSingleTapUp的区别在于，如果触发了onSingleTapConfirmed，那么后面不可能再紧跟着另一个单击行为。</span></span><br><span class="line">            <span class="comment">// 也就是说，这只可能是单击行为，而不可能是双击中的一次单击。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当双击时回调此方法。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">// 创建GestureDetector对象。</span></span><br><span class="line">        mGestureDetector = <span class="keyword">new</span> GestureDetector(getContext(), onGestureListener);</span><br><span class="line">        <span class="comment">// 设置双击事件监听器。</span></span><br><span class="line">        mGestureDetector.setOnDoubleTapListener(onDoubleTapListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前View的触摸事件托管给GestureDetector处理。</span></span><br><span class="line">        mGestureDetector.onTouchEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  SimpleOnGestureListener和SimpleOnGestureListener类里还有其它方法，请自行查看。
-  需要说明的是，若你需要监听双击事件的话就用GestureDetector吧，否则还是自己处理触摸事件比较好。
</code></pre><p><br><strong>本节参考阅读：</strong></p>
<ul>
<li><a href="http://www.cnblogs.com/dyllove98/archive/2013/06/20/3146813.html" target="_blank" rel="noopener">Android UI 学习 自定义的布局 平滑移动 VelocityTracker（）</a></li>
</ul>
<h1 id="第三节-事件分发机制"><a href="#第三节-事件分发机制" class="headerlink" title="第三节 事件分发机制"></a>第三节 事件分发机制</h1><p>　　本节将以触摸事件为范例，从源码的角度进行分析，详细说明事件的分发机制。</p>
<h2 id="Activity的事件分发"><a href="#Activity的事件分发" class="headerlink" title="Activity的事件分发"></a>Activity的事件分发</h2><p>　　上一章我们已经分析过了，当一个事件产生时，它的传递过程，现在我们在它基础上再次扩展一下，最终的顺序为：</p>
<pre><code>WMS -&gt; ViewRootImpl -&gt; DecorView -&gt; Activity -&gt; Window -&gt; DecorView
</code></pre><p>　　即当事件传递给<code>Activity</code>后，<code>Activity</code>会转交给<code>Window</code>，<code>Window</code>再传递给<code>DecorView</code>。</p>
<p><br>　　在Activity类中定义了如下几个方法，当对应的事件发生时，系统会调用它们：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当触摸事件发生时，系统回调此方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当按键事件发生时，系统回调此方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当轨迹球事件发生时，系统回调此方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTrackballEvent</span><span class="params">(MotionEvent ev)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><br>　　既然是以触摸事件为范例，那么我们就从Activity的<code>dispatchTouchEvent</code>方法开始分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　从代码中可以看到，事件会被交给Activity的<code>Window</code>对象的方法<code>superDispatchTouchEvent</code>方法进行分发处理：</p>
<pre><code>-  若该方法返回true则说明事件被某个控件处理了，那么Activity就认为这个事件已经结束了，直接返回即可。
-  若该方法返回false则说明事件没人处理，那么Activity就是把事件交给它的onTouchEvent方法去处理。
</code></pre><p>　　提示：你可以通过重写<code>Activity</code>的<code>dispatchTouchEvent</code>方法且不调用<code>“super.dispatchTouchEvent()”</code>来拦截所有的触摸事件。</p>
<p><br>　　上一章我们说了，<code>Window</code>类的唯一子类就是<code>PhoneWindow</code>类，因此我们接着看它的<code>superDispatchTouchEvent</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　发现它只是转调用了<code>DecorView</code>类的方法，继续深入：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只是简单的调用了父类的实现。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　由于<code>DecorView</code>继承自<code>FrameLayout</code>，此时事件就由Activity传到<code>View</code>手中了。</p>
<h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><p>　　当事件传递到<code>DecorView</code>手中时，一切才刚刚开始而已，后面还有很多步骤要执行。<br>　　接着上面的分析，由于在<code>DecorView</code>和<code>FrameLayout</code>类中都没有<code>dispatchTouchEvent</code>方法的定义，所以我们只能继续去上级父类中找，最终在<code>ViewGroup</code>类中找到了该方法。<br>　　不过由于该方法太长，所以为了看的清晰，我们下面将会分段来分析。</p>
<p><br></p>
<h3 id="拦截事件"><a href="#拦截事件" class="headerlink" title="拦截事件"></a>拦截事件</h3><p>　　我们知道每个<code>MotionEvent</code>都有一个坐标点，当触摸事件传递到<code>ViewGroup</code>手中时，默认情况下<code>ViewGroup</code>会遍历它的所有子<code>View</code>，若该坐标点正好处于某个子<code>View</code>的范围内，则就将触摸事件转发给这个子<code>View</code>去处理。<br>　　不过，这个默认行为是可以改变，即<code>ViewGroup</code>可以将事件拦截下来留给自己处理，而不把事件传递给子<code>View</code>。</p>
<p>　　首先我们来看一下<code>dispatchTouchEvent</code>方法的这段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　上面的代码就是ViewGroup用来判断是否需要拦截触摸事件的，可以看出<code>ViewGroup</code>在如下两种情况时会判断是否拦截当前事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span></span><br></pre></td></tr></table></figure></p>
<p>　　前者很好理解，但<code>mFirstTouchTarget</code>是什么呢？<br>　　其实等我们看到后面的代码时就会知道，当<code>ACTION_DOWN</code>事件由ViewGroup的某个子元素成功处理时，<code>mFirstTouchTarget</code>就会被赋值并指向那个子元素。</p>
<p>　　当上述的两个条件满足其一时，并且第<code>5</code>行代码也返回<code>false</code>时，就会调用ViewGroup类的<code>onInterceptTouchEvent</code>方法：</p>
<pre><code>-  ViewGroup的子类可以重写onInterceptTouchEvent方法，用来决定当前ViewGroup是否拦截本次触摸事件：
   -  若重写方法时返回true，则本次的触摸事件将由当前ViewGroup处理，不会再传递给子View了。
   -  若重写方法时返回false，则表示本次的触摸事件当前ViewGroup将不拦截，事件的传递机制一切照旧。
-  当需要处理滑动冲突时，就可以重写此方法，并依据实际情况返回不同的值，该方法默认返回false。
</code></pre><p>　　上面第<code>5</code>行代码用来获取当前ViewGroup是否开启了<code>“禁止拦截事件”</code>的功能，若开启了，则ViewGroup就无法拦截事件了，可以使用<code>requestDisallowInterceptTouchEvent</code>方法可以修改这个状态。</p>
<p><br>　　总结一下这段代码的价值：</p>
<pre><code>-  onInterceptTouchEvent方法在ViewGroup中定义，用来决定ViewGroup是否拦截事件。
-  onInterceptTouchEvent方法不是每次都调用，如果想提前处理事件，应重写dispatchTouchEvent方法。
-  requestDisallowInterceptTouchEvent方法在ViewGroup中定义，能禁止ViewGroup拦截事件。
</code></pre><p><br></p>
<h3 id="分发事件"><a href="#分发事件" class="headerlink" title="分发事件"></a>分发事件</h3><p>　　上面的代码用来确定ViewGroup是否需要拦截事件，接下来就分别看一下这两种情况。</p>
<p>　　当ViewGroup不拦截事件的时候，事件会向下分发交给它的子View进行处理，这段源代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</span><br><span class="line">            ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">    <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</span><br><span class="line">            ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">    <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">    <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">    <span class="comment">// safer given the timeframe.</span></span><br><span class="line">    <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">        i = childrenCount - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newTouchTarget = getTouchTarget(child);</span><br><span class="line">    <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">        <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resetCancelNextUpFlag(child);</span><br><span class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">        <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">        mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">        <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                    mLastTouchDownIndex = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLastTouchDownIndex = childIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastTouchDownX = ev.getX();</span><br><span class="line">        mLastTouchDownY = ev.getY();</span><br><span class="line">        newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">        alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">    <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　上面这段代码逻辑也很清晰，首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接收这个事件，判断的依据有两个：</p>
<pre><code>-  !canViewReceivePointerEvents(child)：子元素是否在执行动画。
-  !isTransformedTouchPointInView(x, y, child, null)：事件的坐标是否落在了子元素的区域内。
</code></pre><p>　　如果某个元素满足这两个条件，那么就会接着调用<code>dispatchTransformedTouchEvent</code>方法将触摸事件传递该元素。</p>
<p>　　接着查看<code>dispatchTransformedTouchEvent</code>的源码，发现该方法中出现多次类似的<code>if</code>判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 此时ViewGroup会调用继承自View类的方法，来自己处理事件。</span></span><br><span class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 由子View去处理事件。</span></span><br><span class="line">    handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　可以看到不管<code>child</code>是否为<code>null</code>，这段代码最终都会调用<code>dispatchTouchEvent</code>方法来处理事件。</p>
<p>　　那么<code>child</code>是什么呢，它又何时为<code>null</code>呢？<br>　　<code>child</code>就是用来处理本次触摸事件的控件，当ViewGroup拦截了事件时，也会调用<code>dispatchTransformedTouchEvent</code>方法处理事件，只不过<code>child</code>的值会传递为<code>null</code>。源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br></pre></td></tr></table></figure></p>
<p>　　到此我们就清楚了：</p>
<pre><code>-  若ViewGroup没有拦截事件，则会继续将事件分发给子View处理：
   -  若某个子View能处理这个事件，则会调用该子View的dispatchTouchEvent方法进行处理。
   -  若for循环结束后，没有任何一个子View能处理这个事件，则ViewGroup会自己进行处理。
-  若ViewGroup拦截了事件，则它也会自己处理这个事件。
-  当需要ViewGroup自己来处理事件时，ViewGroup会调用继承自View类的dispatchTouchEvent方法来处理。
</code></pre><p><br>　　还有一点要知道，当子View的<code>dispatchTouchEvent</code>方法返回<code>true</code>时，意味着这个事件被处理了，上面的第<code>51</code>行代码就会被执行，然后跳出for循环：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br></pre></td></tr></table></figure></p>
<p>　　其实<code>mFirstTouchTarget</code>真正的赋值过程是在<code>addTouchTarget</code>内完成的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　相应的，<code>ACTION_DOWN</code>之后的事件都会直接传递给<code>mFirstTouchTarget</code>处理，因为<code>for</code>循环寻找能处理事件的子View的过程只在<code>ACTION_DOWN</code>时才会触发。</p>
<p>　　至此我们就得出了一个结论了，不论事件最终是由<code>ViewGroup</code>类处理，还是由某个子<code>View</code>处理，程序最终都会调用<code>View</code>类的<code>dispatchTouchEvent</code>方法，接下来我们就来看一下这个方法。</p>
<h2 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h2><p>　　View对点击事件的处理过程稍微简单一些，因为它没有子元素不需要向下传递事件，所以它需要处理自己的事件。</p>
<p>　　先看它的<code>dispatchTouchEvent</code>方法，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略若干代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　上面代码很简单，分两种方式处理触摸事件：</p>
<pre><code>-  第一种，若当前View处于可用状态，且设置了OnTouchListener，则调用监听器的onTouch方法处理事件。
-  第二种，若第一种方式未能成功处理事件，则调用自己的onTouchEvent方法来处理。
   -  让OnTouchListener优先于onTouchEvent的好处是，方便在外界处理触摸事件。
</code></pre><p><br>　　OnTouchListener的应用场景：</p>
<pre><code>我们使用ScrollView来包含一些控件，同时要求程序可以动态的控制ScrollView是否能滚动。即：
-  在手机横屏的时候，允许它滑动。
-  在手机竖屏的时候，不许它滑动。
</code></pre><p>　　示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处设置的OnTouchListener会优先于ScrollView本身的onTouchEvent方法执行。</span></span><br><span class="line">mScrollView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若当前是竖屏状态，则直接返回true，即不需要在执行ScrollView的onTouchEvent方法了。</span></span><br><span class="line">        <span class="comment">// ScrollView执行滑动的代码是写在onTouchEvent方法中的，该方法不被调用的话，也就没法滑动了。</span></span><br><span class="line">        <span class="keyword">return</span> isShuPing ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br>　　接下来在看一下<code>onTouchEvent</code>方法的源码，由于代码比较长，我们同样分块来看，首先是这段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">        setPressed(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">    <span class="comment">// events, it just doesn't respond to them.</span></span><br><span class="line">    <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　从上面的代码中可以看出，不可用状态下的View照样会消耗事件。</p>
<p>　　接着，如果View设置了代理，那么还会执行<code>TouchDelegate</code>的<code>onTouchEvent</code>方法，代理的工作机制和<code>OnTouchListener</code>，这里就不再细说了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　下面再看一下<code>onTouchEvent</code>中对点击事件的具体处理，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">                (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处省略若干代码...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                <span class="comment">// performClick directly. This lets other visual state</span></span><br><span class="line">                <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                    performClick();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处省略若干代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　从上面的代码来看，只要View的CLICKABLE、LONG_CLICKABLE和CONTEXT_CLICKABLE有一个为true，那么它就会消耗这个事件，即onTouchEvent方法将返回true。</p>
<pre><code>-  View的LONG_CLICKABLE默认为false。
-  View的CLICKABLE是否为false与具体的View类有关，比如Button是可以点击的，TextView是不可点击的。
</code></pre><p>　　同时，当ACTION_UP事件发生时，会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　至此，触摸事件的分发过程的源码分析已经结束了，接下来将利用所学的知识，来处理滑动冲突的问题。</p>
<h1 id="第四节-实战"><a href="#第四节-实战" class="headerlink" title="第四节 实战"></a>第四节 实战</h1><p>　　本节开始综合前面所学的知识。</p>
<h2 id="自定义ScrollView"><a href="#自定义ScrollView" class="headerlink" title="自定义ScrollView"></a>自定义ScrollView</h2><p>　　现在有个需求，创建一个ViewGroup控件，可以通过滑动来在多个子View之间切换，效果和ViewPager类似。</p>
<p>　　代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScrollView</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scroller mScroller = <span class="keyword">new</span> Scroller(getContext());</span><br><span class="line">    <span class="keyword">private</span> VelocityTracker mTracker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTouchSlop;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLastX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mChildIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyScrollView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        setOrientation(HORIZONTAL);</span><br><span class="line">        mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTracker = VelocityTracker.obtain();</span><br><span class="line">        &#125;</span><br><span class="line">        mTracker.addMovement(event);</span><br><span class="line">        <span class="keyword">int</span> currX = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="comment">// 如果当前正在播放动画，则停止它，这样能提供更好的用户体验。</span></span><br><span class="line">                <span class="comment">// 当然也可以把这三行代码注释掉，注释后的效果请自行体验。</span></span><br><span class="line">                <span class="keyword">if</span> (!mScroller.isFinished()) &#123;</span><br><span class="line">                    mScroller.abortAnimation();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">// 在用户手指滑动的同时滚动内容，这样就模仿了ViewPager随着手指滚动的效果。</span></span><br><span class="line">                scrollBy(mLastX - currX, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                mTracker.computeCurrentVelocity(<span class="number">500</span>);</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(mTracker.getXVelocity()) &gt;= mTouchSlop) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getChildCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                        mChildIndex = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mTracker.getXVelocity() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//从左到右滑动</span></span><br><span class="line">                            mChildIndex = (mChildIndex - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : mChildIndex - <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//从右到左滑动</span></span><br><span class="line">                            mChildIndex = (mChildIndex + <span class="number">1</span> &gt; getChildCount() - <span class="number">1</span> ? getChildCount() - <span class="number">1</span> : mChildIndex + <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mTracker.recycle();</span><br><span class="line">                mTracker = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 当手指抬起的时候，开始播放滚动动画，从当前位置开始，到最近的一个子View结束。</span></span><br><span class="line">                mScroller.startScroll(getScrollX(), <span class="number">0</span>, mChildIndex * getChildAt(<span class="number">0</span>).getWidth() - getScrollX(), <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">                postInvalidate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastX = currX;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">            postInvalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　Activity的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        DisplayMetrics dm = getResources().getDisplayMetrics();</span><br><span class="line">        MyScrollView scrollView = <span class="keyword">new</span> MyScrollView(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">int</span>[] colorls = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Color.BLUE, Color.CYAN, Color.YELLOW&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colorls.length; i++) &#123;</span><br><span class="line">            TextView listView = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">            listView.setBackgroundColor(colorls[i]);</span><br><span class="line">            scrollView.addView(listView, <span class="keyword">new</span> LinearLayout.LayoutParams(dm.widthPixels, dm.heightPixels));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setContentView(scrollView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  创建了三个TextView对象，尺寸与屏幕的宽高一致，可以把这两个类复制到项目中，直接运行。
</code></pre><h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2><p>　　本节介绍View体系中的一个深入话题：滑动冲突。只要在界面中存在内外两层同时可以滑动，这个时候就会产生滑动冲突。</p>
<p>　　常见的滑动冲突场景有如下三种：</p>
<pre><code>-  第一种，外部滑动方向和内部滑动方向不一致。
-  第二种，外部滑动方向和内部滑动方向一致。
-  第三种，上面两种情况的嵌套。
</code></pre><p>　　在介绍如何处理这三类冲突之前，要先知道如下几个知识点：</p>
<pre><code>-  ViewGroup重写onInterceptTouchEvent方法可以拦截事件：
   -  若在ACTION_DOWN时返回true，则子View不会接到任何事件，事件将由ViewGroup的onTouchEvent处理。
   -  若在ACTION_MOVE时返回true，则子View会接到ACTION_CANCEL事件，后续事件将交给ViewGroup处理。
   -  若在ACTION_UP时返回true，则子View只会接到ACTION_CANCEL事件，不会接到ACTION_UP事件。
   -  也就是说，只要事件被ViewGroup拦截，那么本事件序列结束之前，都不会在将事件传递给子View。
   -  同时，即便子View处理了事件，只要它没有禁用ViewGroup的拦截事件功能，那么ViewGroup的onInterceptTouchEvent仍会被调用。
-  子View可以通过调用它父View的requestDisallowInterceptTouchEvent方法来禁止其父View拦截事件。
   -  子View无法阻止父View的onInterceptTouchEvent方法接收ACTION_DOWN事件。
   -  子View通常会在接到ACTION_DOWN事件时，禁止其父View拦截事件。
   -  子View通常会在ACTION_MOVE事件中，解除对其父View的禁止，随后父View就能接到ACTION_MOVE事件了。
   -  子View在ACTION_UP事件中解除对其父View的禁止，则父View无法接到ACTION_UP事件。
   -  子View对父View的禁止，只在一个事件序列内有效，即子View在ACTION_DOWN时禁止父View，即便不将父View解禁，当本次事件序列结束，父再次接到ACTION_DOWN事件时就会清除掉禁用状态。
</code></pre><p><br><strong>滑动方向不一致</strong><br>　　接着刚才的范例，我们把TextView换成ListView，就可以重现这种场景，即外部是左右滑动，内部是上下滑动。<br>　　解决的思路是，当用户左右滑动时，让外部View处理事件，当上下滑动时，让内部View处理事件。<br>　　重点在于，我们如何判断用户当前是左右滑，还是上下滑。 有好几种方式：</p>
<pre><code>-  依据水平方向和垂直方向的距离差来判断
-  依据水平方向和垂直方向的速度差来判断
-  依据依据路径和水平方向所形成的夹角来判断
</code></pre><p>　　接下来以“距离差”为例子，做示范，我们只需要在MyScrollView中重写xxx方法即可，其它代码不需要修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLastInterceptX;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mLastInterceptY;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercept = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> currX = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">    <span class="keyword">int</span> currY = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="comment">// 当手指按下的时候，MyScrollView不能拦截事件，否则子View将无法接到事件。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="comment">// 当手指移动时，如果手指在x轴方向上移动的距离比y轴的距离长，则拦截事件。</span></span><br><span class="line">            <span class="comment">// 注意，一旦此处拦截了事件，那么在本次事件序列结束之前，子View都接不到事件。</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(currX - mLastInterceptX) &gt; Math.abs(currY - mLastInterceptY)) &#123;</span><br><span class="line">                intercept = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastInterceptX = currX;</span><br><span class="line">    mLastInterceptY = currY;</span><br><span class="line">    <span class="keyword">return</span> intercept;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　然后是Activity的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        DisplayMetrics dm = getResources().getDisplayMetrics();</span><br><span class="line">        MyScrollView scrollView = <span class="keyword">new</span> MyScrollView(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            ListView listView = <span class="keyword">new</span> ListView(<span class="keyword">this</span>);</span><br><span class="line">            List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">                data.add(<span class="string">"List"</span> + i + <span class="string">" - "</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>, android.R.layout.simple_expandable_list_item_1, data);</span><br><span class="line">            listView.setAdapter(adapter);</span><br><span class="line">            scrollView.addView(listView, <span class="keyword">new</span> LinearLayout.LayoutParams(dm.widthPixels, dm.heightPixels));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setContentView(scrollView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  程序运行后，发现已经解决了滑动冲突。
</code></pre><p><br><strong>内部解决法</strong><br>　　上面是通过修改外部View的代码来解决滑动冲突的，接下来介绍一下如何通过修改内部View的代码来解决滑动冲突：</p>
<pre><code>-  首先，然父ViewGroup不拦截action_DWON事件，拦截另外两个事件。
-  然后，由子View来决定事件处理。
</code></pre><p><br>　　第一步，创建一个MyScrollView2类，所有代码与MyScrollView相同，但下面的代码不同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按下事件不能拦截，否则子View将接不到事件。</span></span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 除了按下事件之外的其它所有事件都会拦截。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　第二步，定义MyListView类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLastInterceptX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLastInterceptY;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currX = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">        <span class="keyword">int</span> currY = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">        <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">            <span class="comment">// 当子View接到按下事件时，设置不允许父View拦截事件。</span></span><br><span class="line">            <span class="comment">// 这意味着当前View一定能接到本次事件序列的后续事件。</span></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                ((ViewGroup)getParent()).requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">// 如果当前View发现用户手指水平方向移动的距离比垂直方向移动的大，则允许父View拦截事件。</span></span><br><span class="line">                <span class="comment">// 又由于MyScrollView2的onInterceptTouchEvent方法会拦截任何“非按下”事件。</span></span><br><span class="line">                <span class="comment">// 这意味着当前View将不会接到后续事件。</span></span><br><span class="line">                <span class="keyword">if</span> (Math.abs(currX - mLastInterceptX) &gt; Math.abs(currY - mLastInterceptY)) &#123;</span><br><span class="line">                    ((ViewGroup)getParent()).requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastInterceptX = currX;</span><br><span class="line">        mLastInterceptY = currY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>　　第三步，Activity的代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        DisplayMetrics dm = getResources().getDisplayMetrics();</span><br><span class="line">        MyScrollView2 scrollView = <span class="keyword">new</span> MyScrollView2(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            MyListView listView = <span class="keyword">new</span> MyListView(<span class="keyword">this</span>);</span><br><span class="line">            List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">                data.add(<span class="string">"MyList"</span> + i + <span class="string">" - "</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayAdapter&lt;String&gt; adapter </span><br><span class="line">                = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>, android.R.layout.simple_expandable_list_item_1, data);</span><br><span class="line">            listView.setAdapter(adapter);</span><br><span class="line">            scrollView.addView(listView, <span class="keyword">new</span> LinearLayout.LayoutParams(dm.widthPixels, dm.heightPixels));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setContentView(scrollView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>语句解释：
-  从实现上来看，内部拦截法要复杂一些，因此推荐采用外部拦截法来解决常见的滑动冲突。
</code></pre><p><br>　　另外两种滑动冲突的处理方式也是类似，暂时就不举例了，以后有空的时候再补上。</p>
<p><br><br></p>

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
        </div>
      

      
      
    </footer>
  </article>


  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="android-ui-005/"
           data-title="UI篇 第五章 自定义控件 - 输入事件" data-url="http://yoursite.com/android-ui-005/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="乐信圣文" />
          <p class="site-author-name" itemprop="name">乐信圣文</p>
          <p class="site-description motion-element" itemprop="description">集大家之成，悟小家之道。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">48</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="http://www.gov.cn/" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一节-基础知识"><span class="nav-number">1.</span> <span class="nav-text">第一节 基础知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二节-触摸事件"><span class="nav-number">2.</span> <span class="nav-text">第二节 触摸事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#滑动位置"><span class="nav-number">2.1.</span> <span class="nav-text">滑动位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#滑动内容"><span class="nav-number">2.2.</span> <span class="nav-text">滑动内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级用法"><span class="nav-number">2.3.</span> <span class="nav-text">高级用法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三节-事件分发机制"><span class="nav-number">3.</span> <span class="nav-text">第三节 事件分发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity的事件分发"><span class="nav-number">3.1.</span> <span class="nav-text">Activity的事件分发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ViewGroup的事件分发"><span class="nav-number">3.2.</span> <span class="nav-text">ViewGroup的事件分发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#拦截事件"><span class="nav-number">3.2.1.</span> <span class="nav-text">拦截事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分发事件"><span class="nav-number">3.2.2.</span> <span class="nav-text">分发事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View的事件分发"><span class="nav-number">3.3.</span> <span class="nav-text">View的事件分发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四节-实战"><span class="nav-number">4.</span> <span class="nav-text">第四节 实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义ScrollView"><span class="nav-number">4.1.</span> <span class="nav-text">自定义ScrollView</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View的滑动冲突"><span class="nav-number">4.2.</span> <span class="nav-text">View的滑动冲突</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乐信圣文</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cutler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("sGcgYofeKOFi2l1XvGrm0PcP-gzGzoHsz", "Sx0mWxj4pkXYm17zT0UnV5Ca");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
